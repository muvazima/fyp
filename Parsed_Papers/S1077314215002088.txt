@&#MAIN-TITLE@&#Continuous sign language recognition: Towards large vocabulary statistical recognition systems handling multiple signers

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Fully automatic, vision based sign language recognition system.


                        
                        
                           
                           Evaluation of class language models, non-gesture modelling and signer adaptation.


                        
                        
                           
                           Novel AAM based face features and combination of hand gesture and face features.


                        
                        
                           
                           Guide to build ASLR systems with public RWTH-PHOENIX data opening field to newcomers.


                        
                        
                           
                           Tackles tracking, features, visual modelling, signer dependency and language modelling.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Sign language recognition

Statistical modelling

Tracking

Visual modelling

Signer dependency

Signer adaptation

@&#ABSTRACT@&#


               
               
                  This work presents a statistical recognition approach performing large vocabulary continuous sign language recognition across different signers. Automatic sign language recognition is currently evolving from artificial lab-generated data to ‘real-life’ data. To the best of our knowledge, this is the first time system design on a large data set with true focus on real-life applicability is thoroughly presented. Our contributions are in five areas, namely tracking, features, signer dependency, visual modelling and language modelling. We experimentally show the importance of tracking for sign language recognition with respect to the hands and facial landmarks. We further contribute by explicitly enumerating the impact of multimodal sign language features describing hand shape, hand position and movement, inter-hand-relation and detailed facial parameters, as well as temporal derivatives. In terms of visual modelling we evaluate non-gesture-models, length modelling and universal transition models. Signer-dependency is tackled with CMLLR adaptation and we further improve the recognition by employing class language models. We evaluate on two publicly available large vocabulary databases representing lab-data (SIGNUM database: 25 signers, 455 sign vocabulary, 19k sentences) and unconstrained ‘real-life’ sign language (RWTH-PHOENIX-Weather database: 9 signers, 1081 sign vocabulary, 7k sentences) and achieve up to 10.0%/16.4% and respectively up to 34.3%/53.0% word error rate for single signer/multi-signer setups. Finally, this work aims at providing a starting point to newcomers into the field.
               
            

@&#INTRODUCTION@&#

Sign language (SLs), the natural languages of the Deaf, are known to be as grammatically complete and rich as their spoken language counterparts. Science discovered SLs a few decades ago and research promises new insights into many human language related fields from language acquisition to automatic processing.

SLs are not international and convey meaning by more than just the moving hands. They make use of both ‘manual features’ (hand shape, position, orientation and movement) and linguistically termed ‘non-manual’ features consisting of the face (eye gaze, mouthing/mouth gestures and facial expression) and the upper body posture (head nods/shakes and shoulder orientation). All of these language components are used in parallel to complement each other, but depending on the context of an utterance, a specific component may or may not be required to interpret the sign. Sometimes, an individual component plays an integral role within the sign, sometimes modifies the meaning, and sometimes provides spatial or temporal context. Furthermore, the different information channels do not share a fixed temporal alignment, but are rather loosely coupled.

Computer vision methods exist to extract features for these different channels. However, SL constitutes an extremely challenging test bed as it incorporates huge variations inherent to natural languages. High signing speed, motion blur, different lighting and view-point-dependent appearance have to be tackled. Furthermore, ambiguity is inherent to SLs, as each movement, each change in eye gaze or each appearance of the tongue may or may not have a grammatical or semantic function depending on the context. Thus, learning features and training classifiers that can be applied to SL recognition must cope with a natural variation seldom present in other tasks. At the same time, it constitutes a very well-defined environment for assessing gesture recognition techniques by providing rules and boundaries for naturalness and intelligibility.

Historically, research on (ALSR) had mainly access to small data sets, limited number of signers and a limited recognition vocabulary. Recently, a very exciting era has started. SL research is moving out of the lab into ‘real-life’ scenarios.

In this paper, we present extensive results and thorough analysis on, to our knowledge, the currently biggest publicly available corpus of continuous SL (RWTH-PHOENIX-Weather). It covers only ‘real-life’ signing recorded on public TV broadcast that has been manually labelled by native speakers. To the best of our knowledge, this is the first time, system design on a large data set with true focus on real-life applicability is thoroughly presented. Our contributions are in five areas, namely tracking, features, signer dependency, visual modelling and language modelling.

We experimentally show the importance of tracking for SL recognition, with respect to the hands and facial landmarks. We further contribute by explicitly enumerating the impact of multimodal SL features describing hand shape, hand position and movement, inter-hand-relation and detailed facial parameters, as well as temporal derivatives. Among these, the combination of hand gesture features and face features is novel, as well as the definition of the high-level face features.

In terms of visual modelling we evaluate non-gesture-models, length modelling and universal transition models. Signer-dependency is tackled using (CMLLR) adaptation. Further, class language models (LMs), CMLLR adaptation, as well as non-gesture-models are the new aspects to ASLR.

In Section 2, we introduce the state-of-the-art in the context of SL recognition and its related sub-fields. In the following two sections, we first present the employed data sets used for evaluating this work (Section 3) and then, in Section 4, the overall recognition system is explained in detail.

The subsequent sections tackle each of the five areas depicted in Fig. 1, giving first the technical details and then the experimental evidences. This is meant to open up the field to newcomers, who can estimate the impact of the most important design decisions. In Section 5, the employed tracking techniques are discussed and their impact with respect to the hands and facial landmarks is given. Section 6 presents the employed features covering most important modalities for SL and shows the impact on overall recognition results. Methods improving the visual modelling are presented in Section 7. Our approach to tackling multiple signers is presented in Section 8. The experimental sections end with our contribution to language modelling in Section 9. Finally, the paper closes with a conclusion and discussion of future work in Sections 10 and 11.

@&#RELATED WORK@&#

This section describes related work in ASLR and its related disciplines. The field evolved from recognising isolated signs of very limited number, articulated by only a single signer toward more complex settings with continuous natural signing of multiple signers. Thereby, the scientific community advances three tracks simultaneously:

                        
                           1.
                           The methods to extract relevant information become more sophisticated and precise, moving from expensive glove- and accelerometer-based setups to non-intrusive computer vision techniques.

The modelling of SL evolves to accommodate both linguistic and data-driven findings, aiming to fully reflect the complexity of the visual language.

The available data sets become more challenging, bigger and closer to real-life signing.

Although more recently ASLR is starting to tackle ‘real-life’ continuous signing data, the majority of work in the community still focuses on the recognition of isolated signs mostly in artificial settings.

Tamura and Kawasaki [64] were the first to start exploring the world of ASLR. They built a system to recognise isolated signs of Japanese SL by modelling the shape, movement and location of the hand using a simple colour segmentation. A lot of the early ASLR systems then employed glove-based motion tracking systems to overcome difficulties with vision-based feature extraction and tracking. This allowed to increase the recognition vocabularies while still achieving high accuracy on simpler tasks. In this way, Kadous [34] distinguished 95 (AUSLAN) signs with accuracies of around 80% using decision trees as classifier. Two years later Liang and Ouhyoung [42] proved to recognise a lexicon of 250 different signs of Taiwanese SL with a similar error rate. However, due to high cost of motion capture systems and thus low real-world applicability, coloured gloves and computer vision techniques started emerging [13].

More advanced visual tracking methods allow to design non-intrusive vision-based approaches that do not require the signers to wear any sort of gloves [3,76]. Starner et al. [60] mounted a camera into a hat and used (HMMs) to recognise a data set of 40 different (ASL) signs. A good overview of ASLR is given in [52]. Furthermore, a number of researchers consider the problem as sign spotting [20,54], where the aim is not to recognise whole sentences, but rather single instances of signs within sentences.


                        Sign sub-units. The need to break whole signs up into sub-units in order to use limited training data more efficiently and in order to allow scaling up of the vocabulary has been an unsolved problem since the early work of Waldron and Kim [70]. Inspired by grapheme-to-phoneme conversion, Pitsikalis et al. [55] extract sub-unit definitions from linguistic annotation in HamNoSys [31] to improve an HMM-based system recognising isolated sign in Greek SL. Cooper et al. [7] compare boosted sequential pattern trees to HMMs using linguistically inspired sub-units and 3D tracking information finding that the trees outperform HMMs for BSL. Koller et al. [39] employ an open SignWriting [63] dictionary to produce and align linguistically meaningful sub-units to signs in German Sign Language (DGS).


                        Unsupervised approaches. To tackle limited or even no available training data, several works [6,36,47,53] aim at exploiting co-occurrences of weak cues to learn hand-based SL models.


                        Handling co-articulation and noise. Signs differ based on the preceding and following sign leading to huge visual variability. To overcome these co-articulation issues, background, noise and co-articulation modelling is needed. Lee et al. [41] investigate adaptive thresholding for individual sign HMM and report recognition improvements on a very limited corpus. Another approach to model co-articulation by Yang et al. [74] uses nested dynamic programming to optimise the time sequence of a co-articulation movement separate from the signs. The method was evaluated on a 39 vocabulary continuous SL corpus and a drastic reduction in error rate by 70% is reported. Kelly et al. [35] use a very similar threshold model approach and report 5.2% improvement on an isolated data set giving testament to the limitations of the corpus used in [41].


                        Modality combination. As mentioned in Section 1, SLs consist of multiple parallel information streams, also referred to as modalities. The fusion of these modalities has been an active field of research within the community. One approach is to use parallel HMMs, which are reported to recognise isolated signs in American and Chinese SL achieving recognition accuracies over 90% [12,71]. Also the fact that modalities can occur in a time asynchronous way has been considered during modelling [22]. Vogler and Metaxas [68] investigate parallel HMMs (PaHMM) for recognition of continuous ASL using cyber-gloves for feature extraction. They report an improvement from 6.7% to 5.8% (WER) for 22 signs using 400 training and 99 test sentences. Theodorakis et al. [65] evaluated product HMMs for the recognition of 93 isolated, Greek SL signs and reported that an asynchronous combination of features outperformed a synchronous combination. Aaran et al. [1] implement a fusion technique for hand shapes and facial expression/shoulder motion that only considers the second feature when the decision based on the first information stream has low confidence. Forster et al. [22] investigate techniques to combine not perfectly synchronous information streams within an HMM-based ASLR system finding that synchronisation just at word boundaries improves the recognition performance. Ong et al. [51] use boosted hierarchical sequential pattern trees to recognise isolated and continuous signs in (BSL), DGS and ASL. Their approach seems promising by allowing to combine partly parallel, not perfectly synchronous features through feature selection by the trees. However, on continuous data the approach faces difficulties.


                        Recognition and translation. As SLs represent full languages with their own grammar and syntax, an additional translation step should follow recognition in order to bridge the communication gap between deaf and hearing. Tokuda et al. [66] mention an important problem: the SL word inventory is much smaller than the spoken language counterpart. However, this is not due to a limited vocabulary, but rather remains an unsolved problem of neglecting SL concepts (i.e. modifier, classifier, indexing) and non-manual features in recognition. Schmidt et al. [59] address this problem by linking a mouthing recognition to the subsequent translation. Other works looking at recognition and translation include Bauer et al. [2], who perform an HMM-based recognition of 100 DGS signs with an accuracy of over 90% and translate it into German text, and [23,61].

Feature extraction is an important step in a recognition system. Over the last decades, different features emerged that proved to be successful in the task of ASLR. This subsection aims at depicting how the task of extracting relevant visual information evolved until now.


                        Basic features. Humans can understand SL by looking at a video sequence, thus the information must be present in the images. As a naïve descriptor, the RGB values of the full image, patches of the tracked hand or the face can serve as features [10,21].

Features are often chosen reflecting the knowledge of sign linguists. It is known that the manual channel (hand shape, orientation, position and movement) conveys a big part of the information in SLs. Tracking the hands and extracting advanced features based on their positions is an important requirement in order to focus feature extraction on relevant video/image regions. Histogram of oriented gradients (HOG) by [11] and other 2D feature point descriptors, such as scale invariant feature transformation (SIFT) [44] are frequently encountered in ASLR approaches [8,53]. HOG-3D [38], an extension over time of HOG, has also shown to produce state-of-the-art-performance [21]. Often trajectories of each single hand or of the interaction of both hands are also used as features [30]. Gabor responses of the forehead have shown to capture non-manual facial expression [43].


                        High-level features. 3D models of hands [45] or faces [58] are used to find higher-level concepts within signing sequences, such as opening the eyes, raising the eyebrows or turning a hand. Recently, viseme patterns have been proposed [40] to reflect mouthings performed during signing. Finally, inspired by the success of neuronal-network-based features in automatic speech recognition, the same concepts are tested for SL [29].

Current publicly available video-based SL corpora can be grouped into one of three categories depending on the scientific community they originated from.

                           
                              1.
                              lexical data sets for everyday use;

linguistic data sets;

large data sets for pattern recognition purposes.

First, there are corpora intended as video-based lexica for SLs allowing to track and analyse changes in the vocabulary of SLs from a linguistic point-of-view. ‘The American Sign Language Lexicon Video Dataset’ [48] forms such a lexicon for American sign language (ASL), containing more than 3000 signs in multiple video views. The AUSLAN SignBank project
                           1
                        
                        
                           1
                           
                              www.auslan.org.au
                           
                         provides annotations on a variety of linguistic levels for 357 videos of Australian SL.

Second, there are corpora intended for linguistic research on isolated signs and continuous sign language allowing to tackle questions like appearance of dialectic variances, differences in pronunciation and sentence structures. Typically, such corpora are created under lab-conditions focusing on certain aspect of sign languages. Corpus NGT [9] contains 12 h of signing in upper-body and front view totalling 64,000 annotated glosses. Since 2008 the corpus has been extended by translations into various spoken languages. Rutkowski et al. [56] created a corpus for Polish sign language containing about 300 h of video footage of 80 deaf signers performing predefined language tasks. The CopyCat corpus [75] covers ASL spoken by children in 420 phrases formed from a vocabulary of 19 signs. For further reference, the University of Hamburg, Germany, created a summary on available linguistic sign language corpora.
                           2
                        
                        
                           2
                           
                              www.sign-lang.uni-hamburg.de/dgs-korpus/index.php/sl-corpora.html
                           
                        
                     

Third, there are corpora either explicitly created or adapted for natural language processing and/or computer vision tasks. In contrast to the linguistic resources, these corpora feature smaller vocabularies of a couple of hundred signs instead of thousands, higher type/token ratios and focus on a small number of closed language domains. The overall goal is to provide minimum statistics to allow for robust training of statistical models while refraining from focusing on special concepts of SLs. Dreuw et al. [17] give an overview on such corpora. Included in this survey are the RWTH-BOSTON corpora originally created for linguistic research at Boston University and adapted for pattern recognition purposes by RWTH Aachen University featuring multiple signers and up to 7768 running glosses with a vocabulary size of 483 glosses. Some works [4,19] present corpora for isolated and continuous sign language recognition for German, Greek, British and French sign language created in the course of the Dicta-Sign
                           3
                        
                        
                           3
                           
                              www.dictasign.eu
                           
                         project. The corpora include sign language videos shot in high-definition in frontal and side view under controlled lab-conditions. Similar to Corpus NGT, the Dicta-Sign corpora contain bird’s eye views of the signers allowing for the study of hand movements in the signing space with regard to the distance from the upper-body of the respective signer. The SIGNUM corpus [69] has been explicitly created for pattern recognition purposes foregoing linguistic considerations and consists of 25 signers and nearly 14,000 running glosses in DGS. Moreover, there is a recent efforts to develop an isolated sign language data set providing depth information [73].

Statistical approaches to (ASR) require large corpora of annotated text respective audio data to learn robust models that generalise well to unseen data. There is a lack of suitable video corpora to develop systems employing statistical methods targeting ASLR. SL corpora are mainly recorded for linguistic research, not providing the type/token ratios needed for statistical modelling. Typically, this kind of data differs significantly from the real language encountered outside the research lab. One concept used particularly in linguistic corpora is the concept of staged communicative events trying to elicit special aspects of SL communication. Staged communication events focus on the interaction between one or more signers. While this makes the language encountered more natural, it raises automatic processing to a difficulty level not yet in focus of the machine learning and pattern recognition community.

The difficulty of the corpora situation is further compounded by the fact that SLs are purely visual languages lacking a writing system. The lack of a normed or at least agreed writing system leads to a variety of different annotation schemes including gloss notation, HamNoSys [31] and SignWriting [63].

In this work, two of the largest publicly available SL video corpora are used to investigate statistical modelling and recognition of SLs.

Both corpora feature DGS and use a gloss annotation scheme. The gloss annotation scheme uses words from the enclosing spoken language, e.g. written English in case of BSL, to describe the meaning of a sign rather than its appearance. The SIGNUM database [69] and the RWTH-PHOENIX-Weather database [24] both come with defined recognition setups for signer dependent ASLR as well as multi-signer setups.

The corpora statistics of the single signer setups for both corpora are subsumed in Table 1
                     
                     , the corpora statistics for the multi-signer setup of SIGNUM and RWTH-PHOENIX-Weather are presented in Table 2.

The SIGNUM database has been created for pattern recognition purposes and aims at reducing the overall complexity of SL and the associated recognition task. Native signers were asked to sign predefined sentences from the domain of everyday life, e.g. going to the cinema, waiting for a bus, and are wearing black long-sleeved clothes while standing in front of an dark blue background. The dataset is carefully controlled with respect to the signer’s position toward the camera, the lighting and the signing speed. In the signer dependent subset of SIGNUM, the signer was asked to sign each of the 603 predefined sentences for training and the 177 test sentences three times. In the multi-signer setup there are 25 signers performing the sentences only once. Due to the overall staged character and the controlled conditions, the SIGNUM database must be considered to contain artificial lab data limiting the expressiveness of results obtained on the signer dependent but also on the multi-signer setup. Results obtained on this database are not expected to easily carry over to more challenging data containing unconstrained SL recorded outside the research lab.

Video recordings belonging to the SIGNUM corpus are recorded at 780 × 580 pixels and 30 frames per second. Example frames from the corpus are presented in Fig. 2
                     .

In contrast to the SIGNUM corpus, the RWTH-PHOENIX-Weather corpus contains SL aired by the German public TV station PHOENIX in the context of weather forecasts as part of the daily news broadcast. Hearing SL interpreters perform live and on-the-fly interpretation of the spoken weather forecast into DGS. This setup leads to SL content that follows the content of the spoken weather forecast and is influenced by the grammatical structure of the spoken weather forecast while featuring speech effects found in unconstrained SL conversations. Among these speech effects are false starts, hesitations and the use of dialectic pronunciation variants.

Lighting conditions and the positioning of the signer in front of the camera are controlled by the TV studio. All videos have a resolution of 210 × 260 pixel and 25 interlaced frames per second. The low temporal and spatial resolution is due to the broadcast method used by the TV station.


                     Fig. 3
                      shows an example frame from the original video stream broadcast by PHOENIX. The broadcast of the weather forecast is overlayed with the SL interpreter leading to the aforementioned spatial resolution of 210 × 260 pixels.


                     Fig. 4
                      shows the distribution of produced signs per signer in the PHOENIX MS corpus. This also underlines the unconstrained signer coverage in the corpus as Signer 1 features more than 25% of the corpus, while Signer 2 just produces less than 1% of the signs (measured by annotated glosses).

For the RWTH-PHOENIX-Weather single signer setup various annotations are available, such as annotated hand and face tracking positions, annotated hand shapes, manual variant annotation and a manually restricted vocabulary to join visually identical signs. For details refer to [24] and visit our website
                        4
                     
                     
                        4
                        
                           http://www-i6.informatik.rwth-aachen.de
                        
                      for download instructions. Methods developed for RWTH-PHOENIX-Weather are expected to carry over to other real-life corpora.


                     Table 3
                      shows all previously published results on the RWTH-PHOENIX-Weather and SIGNUM datasets for comparison. Up to now, the best results have been 10.7% WER by [22] and 22.1% by [21] on SIGNUM single and multi-signer and 38.6% WER by [21] on RWTH-PHOENIX-Weather single signer. No results have been published for the recent RWTH-PHOENIX-Weather multi-signer subset.

Statistical approaches to ASR have matured to a point where they are used in daily life by millions of people around the globe. The great benefit of statistical approaches is their ability to learn from data foregoing the need for hand crafted recognition and grammar rules. Due to the ability to learn from data, statistical approaches lend themselves to ASLR because rules, lexica and even basic concepts such as sentence boundaries are not (yet) defined in the area of SL linguistics.

The ASLR system used in this work is based on the freely available state-of-the-art open source speech recognition system RASR [57] and follows the system schematic in Fig. 5
                     . Given a sequence of features 
                        
                           
                              x
                              1
                              T
                           
                           =
                           
                              x
                              1
                           
                           ,
                           …
                           ,
                           
                              x
                              T
                           
                           ,
                        
                      the system searches for an unknown sequence of words 
                        
                           
                              w
                              1
                              N
                           
                           =
                           
                              w
                              1
                           
                           ,
                           …
                           ,
                           
                              w
                              N
                           
                        
                      for which the sequence of features 
                        
                           x
                           1
                           T
                        
                      best fits the learned models. To this end, the posterior probability 
                        
                           Pr
                           (
                           
                              w
                              1
                              N
                           
                           |
                           
                              x
                              1
                              T
                           
                           )
                        
                      over all possible word sequences 
                        
                           w
                           1
                           N
                        
                      with unknown number of words N is maximised. Using Bayes’ decision rule, casting the visual model
                     
                        
                           Pr
                           (
                           
                              x
                              1
                              T
                           
                           |
                           
                              w
                              1
                              N
                           
                           )
                        
                      as the marginal over all possible HMM temporal state sequence 
                        
                           
                              s
                              1
                              T
                           
                           =
                           
                              s
                              1
                           
                           ,
                           …
                           ,
                           
                              s
                              T
                           
                        
                      for word sequence 
                        
                           
                              w
                              1
                              N
                           
                           ,
                        
                      as well as assuming a first order Markov dependency and maximum approximation,

                        
                           (1)
                           
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                             x
                                             1
                                             T
                                          
                                          →
                                          
                                             
                                                [
                                                
                                                   w
                                                   1
                                                   N
                                                
                                                ]
                                             
                                             
                                                opt
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          =
                                          
                                             argmax
                                             
                                                w
                                                1
                                                N
                                             
                                          
                                          
                                             {
                                             Pr
                                             
                                                (
                                                
                                                   w
                                                   1
                                                   N
                                                
                                                )
                                             
                                             
                                                max
                                                
                                                   s
                                                   1
                                                   T
                                                
                                             
                                             
                                                {
                                                Pr
                                                
                                                   (
                                                   
                                                      x
                                                      t
                                                   
                                                   |
                                                   
                                                      s
                                                      t
                                                   
                                                   ,
                                                   
                                                      w
                                                      1
                                                      N
                                                   
                                                   )
                                                
                                                ·
                                                Pr
                                                
                                                   (
                                                   
                                                      s
                                                      t
                                                   
                                                   |
                                                   
                                                      s
                                                      
                                                         t
                                                         −
                                                         1
                                                      
                                                   
                                                   ,
                                                   
                                                      w
                                                      1
                                                      N
                                                   
                                                   )
                                                
                                                }
                                             
                                             }
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

where 
                        
                           Pr
                           (
                           
                              w
                              1
                              N
                           
                           )
                        
                      is the LM. Pr( · ) denotes the true probability density function (PDF) of the investigated entities. In reality, the true PDFs of the system are unknown and must be estimated from data. We denote, PDFs estimated from data by p( · ). Considering Eq. (1), the visual, the language, as well as the state transition model 
                        
                           Pr
                           (
                           
                              s
                              t
                           
                           |
                           
                              s
                              
                                 t
                                 −
                                 1
                              
                           
                           ,
                           
                              w
                              1
                              N
                           
                           )
                        
                      need to be estimated. The state transition model can be estimated from a lattice of HMM alignments using the extended Baum–Welch algorithm but for speech related tasks it is typically sufficient to pool the model over all words w and assign fixed values (see Eq. (2)) 
                     [57] without losing recognition performance.

                        
                           (2)
                           
                              
                                 
                                    
                                       
                                          p
                                          
                                             (
                                             
                                                s
                                                t
                                             
                                             |
                                             
                                                s
                                                
                                                   t
                                                   −
                                                   1
                                                
                                             
                                             ,
                                             
                                                w
                                                1
                                                N
                                             
                                             )
                                          
                                          =
                                          p
                                          
                                             (
                                             
                                                s
                                                t
                                             
                                             −
                                             
                                                s
                                                
                                                   t
                                                   −
                                                   1
                                                
                                             
                                             )
                                          
                                          =
                                          
                                             {
                                             
                                                
                                                   
                                                      
                                                         
                                                            f
                                                            0
                                                         
                                                         /
                                                         
                                                            ∑
                                                            
                                                               i
                                                               =
                                                               0
                                                            
                                                            2
                                                         
                                                         
                                                            f
                                                            i
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            s
                                                            t
                                                         
                                                         −
                                                         
                                                            s
                                                            
                                                               t
                                                               −
                                                               1
                                                            
                                                         
                                                         =
                                                         0
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            f
                                                            1
                                                         
                                                         /
                                                         
                                                            ∑
                                                            
                                                               i
                                                               =
                                                               0
                                                            
                                                            2
                                                         
                                                         
                                                            f
                                                            i
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            s
                                                            t
                                                         
                                                         −
                                                         
                                                            s
                                                            
                                                               t
                                                               −
                                                               1
                                                            
                                                         
                                                         =
                                                         1
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            f
                                                            2
                                                         
                                                         /
                                                         
                                                            ∑
                                                            
                                                               i
                                                               =
                                                               0
                                                            
                                                            2
                                                         
                                                         
                                                            f
                                                            i
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            s
                                                            t
                                                         
                                                         −
                                                         
                                                            s
                                                            
                                                               t
                                                               −
                                                               1
                                                            
                                                         
                                                         =
                                                         2
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         −
                                                         ∞
                                                      
                                                   
                                                   
                                                      otherwise
                                                   
                                                
                                             
                                          
                                          ,
                                       
                                    
                                 
                              
                           
                        
                     where state sequence variables si
                      denote the state with number y at time i. Thereby 
                        
                           
                              s
                              t
                           
                           −
                           
                              s
                              
                                 t
                                 −
                                 1
                              
                           
                           =
                           0
                        
                      defines a loop in the HMM (stay in the same state) while 
                        
                           
                              s
                              t
                           
                           −
                           
                              s
                              
                                 t
                                 −
                                 1
                              
                           
                           =
                           1
                        
                      describes a forward transition.

The visual model forms the core of the HMM for each word w, modelling for each state s of a word w how on average w is represented in the feature space. As the amount of available data for ASLR is not large enough to benefit from recent advancements in the field of ANN for ASR, GMMs are used in this work. In particular, for state s of word w
                     
                        
                           (3)
                           
                              
                                 
                                    
                                       
                                          p
                                          (
                                          x
                                          |
                                          s
                                          ,
                                          w
                                          )
                                       
                                    
                                    
                                       
                                          =
                                          
                                             ∑
                                             
                                                m
                                                =
                                                1
                                             
                                             M
                                          
                                          
                                             
                                                c
                                                m
                                             
                                             ·
                                             N
                                             
                                                (
                                                x
                                                ,
                                                
                                                   μ
                                                   m
                                                
                                                ,
                                                Σ
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (4)
                           
                              
                                 
                                    
                                       
                                          
                                             ∑
                                             
                                                m
                                                =
                                                1
                                             
                                             M
                                          
                                          
                                             c
                                             m
                                          
                                       
                                    
                                    
                                       
                                          =
                                          1
                                       
                                    
                                 
                              
                           
                        
                     where 
                        
                           N
                           (
                           x
                           ,
                           μ
                           ,
                           Σ
                           )
                        
                      is a multi-variate Gaussian with mean μ, covariance matrix Σ and M is the number of mixture components (can differ between states of the same word). The proposed system uses a globally pooled covariance matrix Σ (see Eq. (3)) to cope with the low amount of training samples per state and word. The expectation maximization (EM) algorithm is used to estimate the sufficient statistics of the GMMs. The number of EM iterations is optimised during the training phase of the system. The LM forms a distribution over the target sequence of words 
                        
                           w
                           1
                           N
                        
                      and is learned from text sequences. In this work, a n-gram LM(
                        
                           n
                           =
                           3
                        
                      and 
                        
                           n
                           =
                           4
                        
                     ) is constructed using modified Kneser–Ney discounting [5]. Discounting allows to shift probability mass from seen n-grams in training such as HEUTE REGEN STARK to lower-order n-grams such as REGEN STARK and especially unseen words. The standard toolbox SRILM 
                     [62] is used to estimate a 3-gram LM for all databases used in this work.

Moving from modelling towards decoding, time-synchronous word-conditioned tree search with dynamic programming is used expanding all state hypotheses Qv
                     (t, s) in all trees for each time step t to decode an unknown SL sequence in a video.

                        
                           (5)
                           
                              
                                 
                                    
                                       
                                          
                                             Q
                                             v
                                          
                                          
                                             (
                                             t
                                             ,
                                             s
                                             )
                                          
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             
                                                
                                             
                                             
                                                
                                                   max
                                                
                                             
                                             
                                                
                                                   σ
                                                
                                             
                                          
                                          
                                             {
                                             p
                                             
                                                (
                                                
                                                   x
                                                   t
                                                
                                                ,
                                                s
                                                |
                                                σ
                                                )
                                             
                                             ·
                                             
                                                Q
                                                v
                                             
                                             
                                                (
                                                t
                                                −
                                                1
                                                ,
                                                σ
                                                )
                                             
                                             }
                                          
                                       
                                    
                                 
                              
                           
                        
                     denoting the joint probability for the best partial path up to time t ending in state s with the best predecessor state σ and predecessor word v. In case of a word end state the state hypotheses of the previous time step are weighted by the LM to obtain new state hypotheses for the next word.

                        
                           (6)
                           
                              
                                 
                                    
                                       
                                          
                                             Q
                                             v
                                          
                                          
                                             (
                                             t
                                             ,
                                             s
                                             =
                                             0
                                             )
                                          
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             max
                                             u
                                          
                                          
                                             {
                                             p
                                             
                                                (
                                                v
                                                |
                                                u
                                                )
                                             
                                             ·
                                             
                                                Q
                                                u
                                             
                                             
                                                (
                                                t
                                                ,
                                                
                                                   S
                                                   v
                                                
                                                )
                                             
                                             }
                                          
                                          ,
                                       
                                    
                                 
                              
                           
                        
                     where u is the predecessor word at the previous time step, v is the predecessor of the new state hypothesis, Sv
                      is the ending state of word v, 
                        
                           s
                           =
                           0
                        
                      is the virtual starting state, and p(v|u) is a 2-gram LM for simplification. A new state tree with predecessor word v and virtual starting state 
                        
                           s
                           =
                           0
                        
                      is then started and the whole process repeated until the end of the current sentence is reached.

The resulting system is implemented in C++ under Linux/Unix making use of multi-threaded linear algebra packages such as BLAS (Intel MKL and similar implementations), and ffmpeg for video processing. A typical recognition experiment in ASLR has a real time factor of three ( 1 min of video footage takes 3 min to process) which can be brought down to close to real-time by pruning of the search space leading to reduced performance in recognition metrics. While model training is parallelised over a computing cluster of 200 computing nodes featuring up to 64 GB of memory and I4 Intel CPUS, decoding is not parallelised as time-synchronous word-conditioned tree search is not parallelisable.

When looking at a deaf person signing, it is immediately apparent that information is conveyed through several moving body parts. But how important is accurate tracking of body parts for ASLR? How much does it contribute to the recognition of SL and how does it compare to just using the whole image for feature extraction?

In the following subsections we describe the tracking methods used to create a state-of-the-art ASLR system capable of handling SL data recorded outside the research lab. In particular, Sections 5.1 and 5.2 detail the algorithms for robustly tracking the signer’s hands and face.

The hands of a signer convey the majority of information when signing in any given SL. Information is encoded in the appearance, shape and movement of the hands. Therefore, it is a necessity to track a signer’s hands to extract movement information as well as to be able to extract features representing the appearance and shape of a particular hand.

State-of-the-art tracking systems mainly follow the tracking-by-detection paradigm in which a complex model of the object to be tracked is learned, the object is detected in every frame, and detections are linked between frames. Drawbacks of the tracking-by-detection paradigm are the taking of potentially wrong local decisions, limiting the context of a tracking decision to the detection result in the current video frame or preceding frames only, as well as additional image segmentation steps to aid the detection of the object of interest. These drawbacks often lead to a tracking loss of the object if the object is occluded, undergoes a change in appearance or shape (i.e. non-rigid object), or moves in a fast and unexpected way.

In this work, we employ a model-free tracking system that is based on dynamic programming allowing to adapt the system to arbitrary tracking tasks by choosing adequate local scoring functions. The dynamic programming tracking (DPT) system is part of the open-source, automatic large vocabulary speech recognition system RASR [14–16].

DPT avoids potentially wrong local decisions by optimising tracking decisions over time and tracing back the best (partial) sequence of tracking decisions at the end of a video sequence thus finding the optimal tracking path with respect to a chosen optimisation criterion. The actual decision on the movement of the object over time is made by tracing back the best, in the sense of accumulated scores, sequence of decisions from the end of the video on. Using this two step procedure of first accumulating scores over time and second tracing back the best sequence of decisions, DPT avoids taking possibly wrong local decisions and yields the optimal solution for the tracking problem at hand [49,50] guaranteeing a smooth tracking path. Optimising over the whole video sequence mitigates the problem of self-occlusion unless the self-occlusion continues for a prolonged period of time (typically 1 s for a 25 fps video).

Taking inspiration from the time alignment problem that needs to be solved in ASR, DPT uses dynamic programming to break down the complex tracking problem in a set of smaller sub-problems. These sub-problems correspond to tracking the object of interest in a certain time window, e.g. from time t to 
                           
                              t
                              +
                              1
                              ,
                           
                         and lead to a series of decision steps over time. As depicted in Fig. 6
                        , DPT is composed of a forward and backward step. In the forward step, every possible area of interest is associated with a score which is maximised over time in the dynamic programming framework. In the backward step, the best object path is created by tracing back the decisions that led to the best overall score after the forward step.

In the following, let Xt
                         denote a video frame of size I × J, 
                           
                              I
                              ,
                              J
                              ⊂
                              N
                              ,
                           
                         pixel at time t and 
                           
                              
                                 l
                                 t
                              
                              =
                              
                                 (
                                 i
                                 ,
                                 j
                                 )
                              
                              :
                              i
                              ∈
                              I
                              ,
                              j
                              ∈
                              J
                           
                         denote a location at time t in Xt
                        . Finding the best tracking path 
                           
                              
                                 l
                                 1
                                 T
                              
                              =
                              
                                 l
                                 1
                              
                              ,
                              …
                              ,
                              
                                 l
                                 t
                              
                              ,
                              …
                              ,
                              
                                 l
                                 T
                              
                              ,
                           
                         1 < t < T, for an object in the image sequence 
                           
                              
                                 X
                                 1
                                 T
                              
                              =
                              
                                 X
                                 1
                              
                              ,
                              …
                              ,
                              
                                 X
                                 t
                              
                              ,
                              …
                              ,
                              
                                 X
                                 T
                              
                           
                         corresponds to maximising the log-likelihood of 
                           
                              l
                              1
                              T
                           
                         given 
                           
                              X
                              1
                              T
                           
                        :

                           
                              (7)
                              
                                 
                                    
                                       
                                          [
                                          
                                             l
                                             1
                                             T
                                          
                                          ]
                                       
                                       
                                          opt
                                       
                                    
                                    =
                                    
                                       argmax
                                       
                                          l
                                          1
                                          T
                                       
                                    
                                    
                                       {
                                       
                                          ∑
                                          
                                             t
                                             =
                                             1
                                          
                                          T
                                       
                                       log
                                       
                                          p
                                          (
                                          
                                             l
                                             t
                                          
                                          |
                                          
                                             l
                                             1
                                             
                                                t
                                                −
                                                1
                                             
                                          
                                          ,
                                          
                                             X
                                             1
                                             T
                                          
                                          )
                                       
                                       }
                                    
                                 
                              
                           
                        Assuming a first-order Markov process, i.e. the location of the object to be tracked at time t depends only on its location at time 
                           
                              t
                              −
                              1
                              ,
                           
                         
                        Eq. (7) is simplified to

                           
                              (8)
                              
                                 
                                    
                                       
                                          [
                                          
                                             l
                                             1
                                             T
                                          
                                          ]
                                       
                                       
                                          opt
                                       
                                    
                                    =
                                    
                                       argmax
                                       
                                          l
                                          1
                                          T
                                       
                                    
                                    
                                       {
                                       
                                          ∑
                                          
                                             t
                                             =
                                             1
                                          
                                          T
                                       
                                       log
                                       
                                          p
                                          (
                                          
                                             l
                                             t
                                          
                                          |
                                          
                                             l
                                             
                                                t
                                                −
                                                1
                                             
                                          
                                          ,
                                          
                                             X
                                             
                                                t
                                                −
                                                1
                                             
                                             t
                                          
                                          )
                                       
                                       }
                                    
                                 
                              
                           
                        
                     

In the DPT framework, Eq. (8) is reformulated by expressing 
                           
                              p
                              (
                              
                                 l
                                 t
                              
                              |
                              
                                 l
                                 
                                    t
                                    −
                                    1
                                 
                              
                              ,
                              
                                 X
                                 
                                    t
                                    −
                                    1
                                 
                                 t
                              
                              )
                           
                         via a relevance scoring function 
                           
                              
                                 q
                                 ˜
                              
                              
                                 (
                                 
                                    l
                                    t
                                 
                                 ,
                                 
                                    l
                                    
                                       t
                                       −
                                       1
                                    
                                 
                                 ,
                                 
                                    X
                                    
                                       t
                                       −
                                       1
                                    
                                    t
                                 
                                 )
                              
                           
                         depending on the object’s position in the current and previous video frame. Normalising to fulfil the requirements of a probability density function and dropping the logarithm because of its monotonicity, Eq. (9) describes the final optimisation criterion of the used DPT framework

                           
                              (9)
                              
                                 
                                    
                                       
                                          [
                                          
                                             l
                                             1
                                             T
                                          
                                          ]
                                       
                                       
                                          opt
                                       
                                    
                                    =
                                    
                                       
                                          a
                                          r
                                          g
                                          m
                                          a
                                          x
                                       
                                       
                                          l
                                          1
                                          T
                                       
                                    
                                    
                                       {
                                       
                                          ∑
                                          
                                             t
                                             =
                                             1
                                          
                                          T
                                       
                                       
                                          
                                             
                                                q
                                                ˜
                                             
                                             
                                                (
                                                
                                                   l
                                                   t
                                                
                                                ,
                                                
                                                   l
                                                   
                                                      t
                                                      −
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   X
                                                   
                                                      t
                                                      −
                                                      1
                                                   
                                                   t
                                                
                                                )
                                             
                                          
                                          
                                             
                                                ∑
                                                l
                                             
                                             
                                                q
                                                ˜
                                             
                                             
                                                (
                                                l
                                                ,
                                                
                                                   l
                                                   
                                                      t
                                                      −
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   X
                                                   
                                                      t
                                                      −
                                                      1
                                                   
                                                   t
                                                
                                                )
                                             
                                          
                                       
                                       }
                                    
                                    ,
                                 
                              
                           
                        where 
                           
                              
                                 q
                                 ˜
                              
                              
                                 (
                                 
                                    l
                                    t
                                 
                                 ,
                                 
                                    l
                                    
                                       t
                                       −
                                       1
                                    
                                 
                                 ,
                                 
                                    X
                                    
                                       t
                                       −
                                       1
                                    
                                    t
                                 
                                 )
                              
                           
                         is split into an image-independent smoothness function 
                           
                              T
                              (
                              
                                 l
                                 t
                              
                              ,
                              
                                 l
                                 
                                    t
                                    −
                                    1
                                 
                              
                              )
                           
                         called jump penalty and an image-dependent scoring function 
                           
                              q
                              (
                              
                                 l
                                 t
                              
                              ,
                              
                                 l
                                 
                                    t
                                    −
                                    1
                                 
                              
                              ,
                              
                                 X
                                 
                                    t
                                    −
                                    1
                                 
                                 t
                              
                              )
                           
                        .

                           
                              (10)
                              
                                 
                                    
                                       
                                          
                                             
                                                q
                                                ˜
                                             
                                             
                                                (
                                                
                                                   l
                                                   t
                                                
                                                ,
                                                
                                                   l
                                                   
                                                      t
                                                      −
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   X
                                                   
                                                      t
                                                      −
                                                      1
                                                   
                                                   t
                                                
                                                )
                                             
                                             =
                                             q
                                             
                                                (
                                                
                                                   l
                                                   t
                                                
                                                ,
                                                
                                                   l
                                                   
                                                      t
                                                      −
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   X
                                                   
                                                      t
                                                      −
                                                      1
                                                   
                                                   t
                                                
                                                )
                                             
                                             −
                                             T
                                             
                                                (
                                                
                                                   l
                                                   t
                                                
                                                ,
                                                
                                                   l
                                                   
                                                      t
                                                      −
                                                      1
                                                   
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Dropping the normalisation term in Eq. (9)
                        
                           5
                        
                        
                           5
                           Constant with regard to argmax function.
                         and using Eq. (10) it is straight forward to define the necessary auxiliary quantities to define the dynamic programming recursive equations. Let D(t, lt
                        ) be the score of the best partial tracking path that starts at time 
                           
                              t
                              =
                              1
                           
                         and ends at time t at location lt
                         and B(t, lt
                        ) the predecessor location corresponding to D(t, lt
                        ). Then the dynamic programming equations are defined by

                           
                              (11)
                              
                                 
                                    
                                       
                                          
                                             D
                                             (
                                             t
                                             ,
                                             
                                                l
                                                t
                                             
                                             )
                                             =
                                          
                                       
                                       
                                          
                                             
                                                max
                                                
                                                   
                                                      l
                                                      ′
                                                   
                                                   ∈
                                                   M
                                                   
                                                      (
                                                      l
                                                      )
                                                   
                                                
                                             
                                             
                                                {
                                                D
                                                
                                                   (
                                                   t
                                                   −
                                                   1
                                                   ,
                                                   
                                                      l
                                                      ′
                                                   
                                                   )
                                                
                                                −
                                                T
                                                
                                                   (
                                                   
                                                      l
                                                      t
                                                   
                                                   ,
                                                   
                                                      l
                                                      ′
                                                   
                                                   )
                                                
                                                +
                                                q
                                                
                                                   (
                                                   
                                                      l
                                                      t
                                                   
                                                   ,
                                                   
                                                      l
                                                      ′
                                                   
                                                   ,
                                                   
                                                      X
                                                      
                                                         t
                                                         −
                                                         1
                                                      
                                                      t
                                                   
                                                   )
                                                
                                                }
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (12)
                              
                                 
                                    
                                       
                                          
                                             B
                                             (
                                             t
                                             ,
                                             
                                                l
                                                t
                                             
                                             )
                                             =
                                          
                                       
                                       
                                          
                                             
                                                argmax
                                                
                                                   
                                                      l
                                                      ′
                                                   
                                                   ∈
                                                   M
                                                   
                                                      (
                                                      l
                                                      )
                                                   
                                                
                                             
                                             
                                                {
                                                D
                                                
                                                   (
                                                   t
                                                   −
                                                   1
                                                   ,
                                                   
                                                      l
                                                      ′
                                                   
                                                   )
                                                
                                                −
                                                T
                                                
                                                   (
                                                   
                                                      l
                                                      t
                                                   
                                                   ,
                                                   
                                                      l
                                                      ′
                                                   
                                                   )
                                                
                                                +
                                                q
                                                
                                                   (
                                                   
                                                      l
                                                      t
                                                   
                                                   ,
                                                   
                                                      l
                                                      ′
                                                   
                                                   ,
                                                   
                                                      X
                                                      
                                                         t
                                                         −
                                                         1
                                                      
                                                      t
                                                   
                                                   )
                                                
                                                }
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              M
                              (
                              l
                              )
                           
                         is the set of possible predecessor locations of l according to a chosen dynamic model.

While Eqs. (11) and (12) describe the forward step of DPT, the backward step is accomplished by tracing back the locations belonging to the best, in the sense of maximal score, tracking path found in the forward step. In particular starting with the location at time T
                        
                           
                              (13)
                              
                                 
                                    
                                       
                                          
                                             
                                                l
                                                
                                                   T
                                                   ,
                                                   
                                                      opt
                                                   
                                                
                                             
                                             =
                                             
                                                argmax
                                                l
                                             
                                             
                                                {
                                                D
                                                
                                                   (
                                                   T
                                                   ,
                                                   l
                                                   )
                                                
                                                }
                                             
                                          
                                       
                                    
                                 
                              
                           
                        belonging to the best tracking path, the remaining locations are found by iteratively looking up

                           
                              (14)
                              
                                 
                                    
                                       
                                          
                                             
                                                l
                                                
                                                   t
                                                   ,
                                                   
                                                      opt
                                                   
                                                
                                             
                                             =
                                             B
                                             
                                                (
                                                t
                                                +
                                                1
                                                ,
                                                
                                                   l
                                                   
                                                      t
                                                      +
                                                      1
                                                   
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        for 
                           
                              t
                              =
                              1
                              ,
                              …
                              ,
                              T
                              −
                              1
                           
                        .

Please note that if 
                           
                              M
                              (
                              l
                              )
                           
                         is small and the image dependent scoring function considers only a small area around a location or only the locations themselves, DPT can be considered an instance of correlation-based optical flow [32] or zero-order warping between images [26,27,37].

Considering real-world SL videos with complex object interactions, it is very difficult to consistently describe and track an object using only one relevance scoring function. Therefore, the DPT framework allows to use a weighted sum of local scoring functions to track an object of interest.

                           
                              (15)
                              
                                 
                                    
                                       
                                          
                                             q
                                             
                                                (
                                                
                                                   l
                                                   t
                                                
                                                ,
                                                
                                                   l
                                                   
                                                      t
                                                      −
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   X
                                                   
                                                      t
                                                      −
                                                      1
                                                   
                                                   t
                                                
                                                )
                                             
                                             =
                                             
                                                ∑
                                                
                                                   n
                                                   =
                                                   1
                                                
                                                N
                                             
                                             
                                                α
                                                n
                                             
                                             ·
                                             
                                                q
                                                n
                                             
                                             
                                                (
                                                
                                                   l
                                                   t
                                                
                                                ,
                                                
                                                   l
                                                   
                                                      t
                                                      −
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   X
                                                   
                                                      t
                                                      −
                                                      1
                                                   
                                                   t
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The local scoring functions 
                           
                              
                                 q
                                 n
                              
                              
                                 (
                                 
                                    l
                                    t
                                 
                                 ,
                                 
                                    l
                                    
                                       t
                                       −
                                       1
                                    
                                 
                                 ,
                                 
                                    X
                                    
                                       t
                                       −
                                       1
                                    
                                    t
                                 
                                 )
                              
                           
                         cover different aspects of an object and can be calculated on dense probability images calculated from the original video frames. Examples of such dense probability images are skin-colour probability images or face probability images computed from responses of the Viola and Jones face detector [67].

In the following, Qt
                         denotes the tracking window and it contains all locations within a rectangle of size w × h centred on the image location lt
                        .

                           
                              (16)
                              
                                 
                                    
                                       
                                          
                                             
                                                Q
                                                t
                                             
                                             :
                                             =
                                             
                                                {
                                                
                                                   l
                                                   t
                                                
                                                +
                                                l
                                                :
                                                l
                                                ∈
                                                Q
                                                }
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (17)
                              
                                 
                                    
                                       
                                          
                                             Q
                                             :
                                             =
                                             {
                                             (
                                             i
                                             ,
                                             j
                                             )
                                             :
                                             −
                                             w
                                             ≤
                                             i
                                             ≤
                                             w
                                             ,
                                             
                                             −
                                             h
                                             ≤
                                             j
                                             ≤
                                             h
                                             }
                                          
                                       
                                    
                                 
                              
                           
                        The size of the tracking window is fixed and equal for all local scoring functions used within the DPT framework and is a crucial parameter to be adjusted to the video sequence at hand. If w or h is chosen too small tracking performance degrades because the object of interest is not enclosed in the tracking window. Conversely, if w or h is chosen too large the score reflects the background rather than the object of interest. X[l] denotes the feature vector (can be as simple as a single grey-scale value) at pixel 
                           
                              l
                              =
                              (
                              i
                              ,
                              j
                              )
                           
                         in image X. If X[l] describes a vector of size m in the following equations the mathematical operations are carried out channel-wise, i.e. 
                           
                              X
                              
                                 [
                                 l
                                 ]
                              
                              −
                              X
                              
                                 [
                                 u
                                 ]
                              
                              =
                              
                                 ∑
                                 m
                              
                              
                                 (
                                 X
                                 
                                    
                                       [
                                       l
                                       ]
                                    
                                    m
                                 
                                 −
                                 X
                                 
                                    
                                       [
                                       u
                                       ]
                                    
                                    m
                                 
                                 )
                              
                           
                         but the channel-wise notation is dropped for readability.

The majority of scoring functions used in this work are based on the assumption that the object of interest moves more than every other object within the sequence of images under consideration. This assumption holds even in the context of complex and cluttered backgrounds as long as the background remains static. Scoring function used in this work are:

Assuming a high enough frame rate, i.e. temporal sampling, the object of interest is nearly constant in its appearance leading to a scoring function dubbed constant-object-appearance, implying a small distance between the appearance of the same object in consecutive video frames

                              
                                 (18)
                                 
                                    
                                       
                                          
                                             
                                                q
                                                
                                                   (
                                                   
                                                      l
                                                      t
                                                   
                                                   ,
                                                   
                                                      l
                                                      
                                                         t
                                                         −
                                                         1
                                                      
                                                   
                                                   ,
                                                   
                                                      X
                                                      
                                                         t
                                                         −
                                                         1
                                                      
                                                      t
                                                   
                                                   )
                                                
                                                =
                                                −
                                                
                                                   ∑
                                                   
                                                      l
                                                      ∈
                                                      Q
                                                   
                                                
                                                
                                                   
                                                      (
                                                      
                                                         X
                                                         t
                                                      
                                                      
                                                         [
                                                         
                                                            l
                                                            t
                                                         
                                                         +
                                                         l
                                                         ]
                                                      
                                                      −
                                                      
                                                         X
                                                         
                                                            t
                                                            −
                                                            1
                                                         
                                                      
                                                      
                                                         [
                                                         
                                                            l
                                                            
                                                               t
                                                               −
                                                               1
                                                            
                                                         
                                                         +
                                                         l
                                                         ]
                                                      
                                                      )
                                                   
                                                   2
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        


                           Eq. (18) describes a negative distance in order to fit into the maximisation framework of Eq. (9). The taken assumption is similar to the base assumption of optical-flow [32] and a prerequisite for particle filtering techniques [33].

Following the high frame rate assumption, we assume that the background of the object to be tracked is constant or nearly constant between consecutive video frames. This implies that only those regions change between consecutive frames where the object is in the current frame Xt
                            and where it has been in the previous frame 
                              
                                 X
                                 
                                    t
                                    −
                                    1
                                 
                              
                           . Accordingly, the difference between all other parts of the consecutive video frame pair should be minimal.

                              
                                 (19)
                                 
                                    
                                       
                                          
                                             
                                                q
                                                (
                                                
                                                   l
                                                   t
                                                
                                                ,
                                                
                                                   l
                                                   
                                                      t
                                                      −
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   X
                                                   
                                                      t
                                                      −
                                                      1
                                                   
                                                   t
                                                
                                                )
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      l
                                                      ∈
                                                      
                                                         Q
                                                         t
                                                      
                                                   
                                                
                                                
                                                   
                                                      (
                                                      
                                                         X
                                                         t
                                                         ′
                                                      
                                                      
                                                         [
                                                         l
                                                         ]
                                                      
                                                      )
                                                   
                                                   2
                                                
                                                +
                                                
                                                   ∑
                                                   
                                                      l
                                                      ∈
                                                      
                                                         Q
                                                         
                                                            t
                                                            −
                                                            1
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      (
                                                      
                                                         X
                                                         t
                                                         ′
                                                      
                                                      
                                                         [
                                                         l
                                                         ]
                                                      
                                                      )
                                                   
                                                   2
                                                
                                                −
                                                
                                                   ∑
                                                   
                                                      l
                                                      ∈
                                                      
                                                         Q
                                                         t
                                                      
                                                      ∩
                                                      
                                                         Q
                                                         
                                                            t
                                                            −
                                                            1
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      (
                                                      
                                                         X
                                                         t
                                                         ′
                                                      
                                                      
                                                         [
                                                         l
                                                         ]
                                                      
                                                      )
                                                   
                                                   2
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where 
                              
                                 
                                    X
                                    t
                                    ′
                                 
                                 =
                                 
                                    X
                                    t
                                 
                                 −
                                 
                                    X
                                    
                                       t
                                       −
                                       1
                                    
                                 
                              
                           .

The human body has certain kinematic constraints with regard to where in a video frame e.g. the right hand of a person can be when facing the camera. We encode a soft form of this constraint into the tracking framework via

                              
                                 (20)
                                 
                                    
                                       
                                          
                                             
                                                q
                                                
                                                   (
                                                   
                                                      l
                                                      t
                                                   
                                                   =
                                                   
                                                      (
                                                      i
                                                      ,
                                                      j
                                                      )
                                                   
                                                   ,
                                                   
                                                      l
                                                      
                                                         t
                                                         −
                                                         1
                                                      
                                                   
                                                   ,
                                                   
                                                      X
                                                      
                                                         t
                                                         −
                                                         1
                                                      
                                                      t
                                                   
                                                   )
                                                
                                                =
                                                
                                                   {
                                                   
                                                      
                                                         
                                                            
                                                               ⌊
                                                               λ
                                                               ·
                                                               
                                                                  τ
                                                                  i
                                                               
                                                               ⌋
                                                            
                                                         
                                                         
                                                            
                                                               i
                                                               >
                                                               ⌊
                                                               λ
                                                               ·
                                                               
                                                                  τ
                                                                  i
                                                               
                                                               ⌋
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               i
                                                               −
                                                               
                                                                  τ
                                                                  i
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  τ
                                                                  i
                                                               
                                                               ≤
                                                               i
                                                               ≤
                                                               
                                                                  ⌊
                                                                  λ
                                                                  ·
                                                                  
                                                                     τ
                                                                     i
                                                                  
                                                                  ⌋
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               −
                                                               f
                                                               (
                                                               
                                                                  τ
                                                                  i
                                                               
                                                               −
                                                               i
                                                               )
                                                            
                                                         
                                                         
                                                            
                                                               0
                                                               ≤
                                                               i
                                                               <
                                                               
                                                                  τ
                                                                  i
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where 0 < τi
                            < I and λ ≥ 1 are constants, and 
                              
                                 f
                                 :
                                 N
                                 ↦
                                 [
                                 0
                                 ,
                                 ∞
                                 )
                                 ⊂
                                 R
                              
                            is a continuous function on 
                              
                                 [
                                 0
                                 ,
                                 
                                    τ
                                    i
                                 
                                 ]
                                 ⊂
                                 N
                              
                           . τi
                            denotes the horizontal axis which the object of interest should not cross due to kinematic constraints. λ governs the width of the linear part of the scoring function.

Considering the problem of tracking both hands of a signer, soft spatial pruning is used to partition the video frame in a region for the dominant hand and one for the non-dominant hand by choosing τi
                            accordingly. Adjusting Eq. (20) for the non-dominant hand is straight-forward.

In the context of tracking a person’s hand while the person is signing the issue of the tracker getting stuck at the person’s face arises. This happens primarily when the tracker utilises non-skincolour suppression to increase tracking performance. To reduce the probability of the tracker getting stuck at the signer’s face we use a spring-like function centred on the face position to reduce the score of the hand tracker in the face region.

                              
                                 (21)
                                 
                                    
                                       
                                          
                                             
                                                q
                                                
                                                   (
                                                   
                                                      l
                                                      t
                                                   
                                                   ,
                                                   
                                                      l
                                                      
                                                         t
                                                         −
                                                         1
                                                      
                                                   
                                                   ,
                                                   
                                                      X
                                                      
                                                         t
                                                         −
                                                         1
                                                      
                                                      t
                                                   
                                                   )
                                                
                                                =
                                                
                                                   ∑
                                                   
                                                      l
                                                      ∈
                                                      
                                                         Q
                                                         t
                                                      
                                                   
                                                
                                                
                                                   1
                                                   −
                                                   
                                                      f
                                                      fp
                                                   
                                                   
                                                      (
                                                      
                                                         X
                                                         t
                                                      
                                                      )
                                                   
                                                   
                                                      [
                                                      l
                                                      ]
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where 
                              
                                 
                                    f
                                    fp
                                 
                                 
                                    (
                                    X
                                    )
                                 
                                 :
                                 
                                    R
                                    
                                       I
                                       ×
                                       J
                                    
                                 
                                 ↦
                                 
                                    
                                       [
                                       0
                                       ,
                                       1
                                       ]
                                    
                                    
                                       I
                                       ×
                                       J
                                    
                                 
                                 ⊂
                                 
                                    R
                                    
                                       I
                                       ×
                                       J
                                    
                                 
                              
                            denotes the face probability image of X which is obtained via probabilistic face detectors [59,67] or the face tracker described in Section 5.2.

An issue unique to hand tracking for humans shown in frontal pose in a video frame is that both hands are nearly indistinguishable from an algorithmic point of view. Using a spring-like function, we can utilise the tracked position of e.g. the right hand to reduce the search space when tracking the e.g. left hand since it is unlikely that both hands overlap for a prolonged period of time when a person is signing.

                              
                                 (22)
                                 
                                    
                                       
                                          
                                             
                                                λ
                                                
                                                   (
                                                   
                                                      l
                                                      t
                                                   
                                                   ,
                                                   
                                                      l
                                                      
                                                         t
                                                         −
                                                         1
                                                      
                                                   
                                                   |
                                                   
                                                      l
                                                      t
                                                      Ξ
                                                   
                                                   =
                                                   
                                                      (
                                                      u
                                                      ,
                                                      v
                                                      )
                                                   
                                                   )
                                                
                                                =
                                                −
                                                
                                                   ∑
                                                   
                                                      l
                                                      =
                                                      
                                                         (
                                                         i
                                                         ,
                                                         j
                                                         )
                                                      
                                                      ∈
                                                      
                                                         Q
                                                         t
                                                      
                                                      ∩
                                                      
                                                         Q
                                                         t
                                                         Ξ
                                                      
                                                   
                                                
                                                
                                                   1.0
                                                   −
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  (
                                                                  u
                                                                  −
                                                                  i
                                                                  )
                                                               
                                                               2
                                                            
                                                            +
                                                            
                                                               
                                                                  (
                                                                  v
                                                                  −
                                                                  j
                                                                  )
                                                               
                                                               2
                                                            
                                                         
                                                      
                                                      
                                                         min
                                                         (
                                                         
                                                            w
                                                            Ξ
                                                         
                                                         ,
                                                         
                                                            h
                                                            Ξ
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (23)
                                 
                                    
                                       
                                          
                                             
                                                q
                                                
                                                   (
                                                   
                                                      l
                                                      t
                                                   
                                                   ,
                                                   
                                                      l
                                                      
                                                         t
                                                         −
                                                         1
                                                      
                                                   
                                                   ,
                                                   
                                                      X
                                                      
                                                         t
                                                         −
                                                         1
                                                      
                                                      t
                                                   
                                                   |
                                                   
                                                      l
                                                      1
                                                      
                                                         T
                                                         ,
                                                         Ξ
                                                      
                                                   
                                                   )
                                                
                                                
                                                   )
                                                   =
                                                
                                                
                                                   {
                                                   
                                                      
                                                         
                                                            
                                                               λ
                                                               (
                                                               
                                                                  l
                                                                  t
                                                               
                                                               ,
                                                               
                                                                  l
                                                                  
                                                                     t
                                                                     −
                                                                     1
                                                                  
                                                               
                                                               |
                                                               
                                                                  l
                                                                  t
                                                                  Ξ
                                                               
                                                               )
                                                            
                                                         
                                                         
                                                            
                                                               λ
                                                               (
                                                               
                                                                  l
                                                                  t
                                                               
                                                               ,
                                                               
                                                                  l
                                                                  
                                                                     t
                                                                     −
                                                                     1
                                                                  
                                                               
                                                               |
                                                               
                                                                  l
                                                                  t
                                                                  Ξ
                                                               
                                                               )
                                                               ≥
                                                               0.0
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               0.0
                                                            
                                                         
                                                         
                                                            
                                                               otherwise
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where 
                              
                                 l
                                 t
                                 Ξ
                              
                            is the hand location detected in the first tracking pass with tracking window 
                              
                                 Q
                                 t
                                 Ξ
                              
                            of size 
                              
                                 
                                    w
                                    Ξ
                                 
                                 ·
                                 
                                    h
                                    Ξ
                                 
                              
                           .

Using other hand suppression, DPT processes the video sequence twice by first tracking the dominant hand and then using the resulting tracking locations as an additional information source in tracking the non-dominant hand.

Active appearance model (AAMs) were introduced by Edwards et al. [18] in 1998 and notably reformulated by Matthews et al. [46] in 2004. They attempt to recover an object’s shape s by generatively fitting a deformable shape model to the image data. s is defined as a vector of v 2-dimensional landmark points representing a meaningful part of the object, such as an eye corner in the human face:

                           
                              (24)
                              
                                 
                                    
                                       
                                          
                                             s
                                             =
                                             
                                                
                                                   (
                                                   
                                                      x
                                                      1
                                                   
                                                   ,
                                                   
                                                      y
                                                      1
                                                   
                                                   ,
                                                   
                                                      x
                                                      2
                                                   
                                                   ,
                                                   
                                                      y
                                                      2
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      x
                                                      v
                                                   
                                                   ,
                                                   
                                                      y
                                                      v
                                                   
                                                   )
                                                
                                                ⊺
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

AAMs model shape deformation using a point density model (PDM), which is a parametric linear subspace model learned statistically by principal components analysis (PCA) on a set of training shape examples, such as shown in Fig. 7. Thereby, any shape s of the deformable object can be expressed as a linear combination of a base shape s
                        0 and n shape vectors s
                        
                           i
                        :

                           
                              (25)
                              
                                 
                                    
                                       
                                          
                                             s
                                             =
                                             
                                                s
                                                0
                                             
                                             +
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                p
                                                i
                                             
                                             
                                                s
                                                i
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

AAMs propose to model the coupling between the PDM and the image data, i.e. the predictions on the PDM’s landmarks locations given a target image, using an appearance model representing the object. This is also a parametric linear subspace model, obtained by applying PCA to shape-normalised training example images, which involves the warping to a reference frame. This is typically done by piece-wise affine warping functions defined between each example shape and the base shape s
                        0. The generative appearance model is then used to express any object’s appearance A(x) as a base appearance A
                        0(x) plus a linear combination of m appearance images Ai
                        (x):

                           
                              (26)
                              
                                 
                                    A
                                    
                                       (
                                       x
                                       )
                                    
                                    =
                                    
                                       A
                                       0
                                    
                                    
                                       (
                                       x
                                       )
                                    
                                    +
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       m
                                    
                                    
                                       λ
                                       i
                                    
                                    
                                       A
                                       i
                                    
                                    
                                       (
                                       x
                                       )
                                    
                                    
                                    ∀
                                    x
                                    ∈
                                    R
                                    
                                       (
                                       
                                          s
                                          0
                                       
                                       )
                                    
                                 
                              
                           
                        where 
                           
                              R
                              (
                              
                                 s
                                 0
                              
                              )
                           
                         denotes the set of pixel locations within the region defined by the base shape s
                        0, i.e. the reference frame for the object’s appearance.

Given these two generative models and following the independent AAM formulation proposed in [46], registration can be seen as an image matching problem between the synthetic model image and the shape-normalised target image; the fitting goal can therefore be expressed as finding the parameters 
                           
                              p
                              =
                              
                                 
                                    (
                                    
                                       p
                                       1
                                    
                                    ,
                                    
                                       p
                                       2
                                    
                                    ,
                                    …
                                    ,
                                    
                                       p
                                       n
                                    
                                    )
                                 
                                 ⊺
                              
                           
                         and 
                           
                              
                                 λ
                              
                              =
                              
                                 
                                    (
                                    
                                       λ
                                       1
                                    
                                    ,
                                    
                                       λ
                                       2
                                    
                                    ,
                                    …
                                    ,
                                    
                                       λ
                                       m
                                    
                                    )
                                 
                                 ⊺
                              
                           
                         that minimise

                           
                              (27)
                              
                                 
                                    
                                       
                                          
                                             
                                                ∑
                                                
                                                   x
                                                   ∈
                                                   R
                                                   (
                                                   
                                                      s
                                                      0
                                                   
                                                   )
                                                
                                             
                                             
                                                
                                                   [
                                                   
                                                      A
                                                      0
                                                   
                                                   
                                                      (
                                                      x
                                                      )
                                                   
                                                   +
                                                   
                                                      ∑
                                                      
                                                         i
                                                         =
                                                         1
                                                      
                                                      m
                                                   
                                                   
                                                      λ
                                                      i
                                                   
                                                   
                                                      A
                                                      i
                                                   
                                                   
                                                      (
                                                      x
                                                      )
                                                   
                                                   −
                                                   I
                                                   
                                                      (
                                                      W
                                                      
                                                         (
                                                         x
                                                         ;
                                                         p
                                                         )
                                                      
                                                      )
                                                   
                                                   ]
                                                
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where I is the target image and W(x; p) is a piece-wise affine warping function which projects a pixel location x from the reference frame to the target image frame, depending on the PDM’s parameters p. The minimisation of this quantity is non-linear in the parameters p and must be solved iteratively by linear approximation, typically using the Gauss–Newton algorithm.

AAM variants mostly differ in the way they parameterise the linear approximation to derive the parameters’ update equation. We chose to use the efficient version of the simultaneous inverse-compositional AAM (SICAAM) proposed in [28], which is more robust to large variations in shape and appearance. Moreover, we follow [72] in order to cope with large off-plane head rotations, which are also common in SL and can lead a 2D AAM to failure. Thus, in the present work a 3D PDM is estimated using a non-rigid structure-from-motion algorithm on the training shapes, and is then involved in the optimisation process which incorporates a regularisation term encouraging the 2D shape controlled by the 2D PDM to be a valid projection of the 3D PDM. Similar to the 2D PDM, the 3D PDM expresses any 3D shape S as a 3D base shape S
                        0 plus a linear combination of 
                           
                              n
                              ¯
                           
                         3D shape vectors S
                        
                           i
                        :

                           
                              (28)
                              
                                 
                                    
                                       
                                          
                                             S
                                             =
                                             
                                                S
                                                0
                                             
                                             +
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   n
                                                   ¯
                                                
                                             
                                             
                                                
                                                   p
                                                   ¯
                                                
                                                i
                                             
                                             
                                                S
                                                i
                                             
                                          
                                       
                                    
                                 
                              
                           
                        Note that the 3D PDM is also involved in the calculation of the high-level facial features described in Section 6.

In SLs, the dominant hand of a signer carries more information than the non-dominant hand. In our datasets, the majority of signers is right hand dominant. Hand-patch features based on tracked locations of the hands allow to put more emphasis on the signs themselves. Hand and face locations have been tracked using the scoring functions detailed previously on lighting and contrast normalised video frames (unless a scoring function requires probability images). In the following experiments, for RWTH-PHOENIX-Weather, hand-patches of size 50 × 70 have been cropped around the tracked position where 50 × 70 pixel is the average size of an hand in the RWTH-PHOENIX-Weather database. Three consecutive hand-patches are concatenated and each colour channel (red, green and blue) is reduced to its 70 most discriminative components. For the SIGNUM database, grey-scale hand-patches of size 30 × 30 have been cropped centred on the tracked location. A temporal context of ±1 frame is applied before reducing the feature to its 200 most discriminative components. To gauge if tracking is necessary for ASLR in contrast to taking the whole video frame as feature, we down-scale the original full video frame from 210 × 260 to 53 × 65 for the RWTH-PHOENIX-Weather corpus (see Table 1) and apply the same feature extraction pipeline as for the tracking based features (channel-wise PCA to 70 dimensions). For the SIGNUM database, grey-scale full images down-scaled from 575 × 575 (cropped from the original resolution 578 × 776) to 32 × 32 are used. Baseline results for both databases are reported in Table 4
                        .

In the face related experiments the face patches represent down-sampled face crops (RWTH-PHOENIX-Weather 22 × 35 pixels and SIGNUM 32 × 32 pixels), three frames temporally concatenated and PCA reduced to 200 dimensions. The AAM-face features represent 15 shape and 15 texture AAM coefficients originating from the AAM described in Section 5.2. For RWTH-PHOENIX-Weather five temporal frames have been concatenated and PCA reduced to 210 dimensions, for SIGNUM nine frames have been reduced to 200 dimensions.


                        Table 4 clearly shows that full video image features are outperformed by hand-patch features. In case of RWTH-PHOENIX-Weather the overall result is improved by 22% WER absolute and on the SIGNUM database the result is improved by 12% WER where WER measures the required numbers of deletions, insertions and substitution operations to transform the recognised word sequence into the correct word sequences. Results in Table 4 show that full image features contain too much variation to be effectively handled by the current prototype. Furthermore, the necessary down-scaling of the full images reduces the information contained in the images and renders the identification of individual signs difficult.

Tracking based features like hand-patches suffer from error propagation in the overall pipeline. If the tracked position of the object deviates too far from the real position, the corresponding hand-patch either does not match the trained model of the recogniser or introduces strong variation in the training process, severely limiting the model’s ability to generalise over unseen data. Table 5
                         shows the influence of the tracking performance measured in TrackEr(
                           
                              τ
                              =
                              20
                           
                        ) (Eq. (29)) against the recognition performance measured in WER.

TrackEr is the tracking error, measured as the average discrepancy between an annotated ground truth object location and the location found by automatic tracking:

                           
                              (29)
                              
                                 
                                    
                                       
                                          
                                             TrackEr
                                             =
                                             
                                                1
                                                T
                                             
                                             
                                                ∑
                                                
                                                   t
                                                   =
                                                   1
                                                
                                                T
                                             
                                             
                                                δ
                                                τ
                                             
                                             
                                                (
                                                
                                                   l
                                                   t
                                                
                                                ,
                                                
                                                   
                                                      l
                                                      ^
                                                   
                                                   t
                                                
                                                )
                                             
                                             ,
                                             
                                             
                                                δ
                                                τ
                                             
                                             
                                                (
                                                l
                                                ,
                                                m
                                                )
                                             
                                             :
                                             =
                                             
                                                {
                                                
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         
                                                            ∥
                                                            l
                                                            −
                                                            m
                                                            ∥
                                                            <
                                                            τ
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         1
                                                      
                                                      
                                                         
                                                            o
                                                            t
                                                            h
                                                            e
                                                            r
                                                            w
                                                            i
                                                            s
                                                            e
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where l and m are two 2D coordinates in a video frame and τ is the deviation threshold.

To measure the impact of the tracking performance, the parameters of the DPT framework have been adjusted to reach a specific TrackEr. For all experiments the parameters of the proposed ASLR system have been kept fixed for training and testing being optimised of the best result obtained at TrackEr of 11.6. For each TrackEr level the whole system has been retrained using features extracted based on a tracking achieving the performance level in question. The first row of the table showing a TrackEr of 0 is based on ground-truth annotation for the whole training and testing set for the RWTH-PHOENIX-Weather signer specific subset.

Results depicted in Table 5 show a clear connection between TrackEr and WER for continuous SL recognition. The higher the TrackEr gets the worse the recognition result is. An improvement of the used tracking method in order to achieve better and more consistent tracking results will have a positive impact on SL recognition performance. The result of 48.3% of the perfect tracking result indicates the limit of performance reachable with hand-patch features alone and should not be interpreted as the overall gain possible with improved tracking on the used database. It stands to reason that features capturing the overall shape of hand while being invariant to the majority of noise present in the video frame (e.g. motion blur) will benefit from better tracking in the same manner as hand-patch features.

SLs convey meaning by several information streams in parallel: besides the hand shape, orientation and position, the upper body pose, and also facial expression, such as mouthing, eye brows and eye gaze are important. The goal of this section is to assess the impact of each feature adding up to a state-of-the-art recognition system.

Instead of PCA-reduced hand patches as in Section 5.3, we employ HOG-3D Features 
                     [45], which explicitly capture the edges of the hands spatially and also temporally and are therefore much more robust against illumination differences. The HOG-3D histograms are computed using a temporal context of seven frames. A large part of the information in SL is contained in the temporal sequence. We thus add more temporal context by stacking together ± 4 video frames for SIGNUM and ± 2 frames for PHOENIX. Subsequently, we perform a PCA reduction to 200 and 210 dimensions for SIGNUM and PHOENIX respectively. HOG-3D are used for ASLR in this work and not for tracking.


                     Trajectories with Position constitute a second important manual feature. The trajectory motion is understood as a main direction and a shape. Given the hand position 
                        
                           
                              u
                              t
                           
                           =
                           
                              (
                              x
                              ,
                              y
                              )
                           
                        
                      at a time t, the velocity vector 
                        
                           
                              m
                              t
                           
                           =
                           
                              u
                              t
                           
                           −
                           
                              u
                              
                                 t
                                 −
                                 δ
                              
                           
                        
                      points in the direction of the movement. However, a more robust method is used in this work. It is based on the estimation of the covariance matrix within a time window 
                        
                           2
                           δ
                           +
                           1
                        
                      around time t, as shown in Eq. (30),

                        
                           (30)
                           
                              
                                 
                                    
                                       
                                          
                                             Σ
                                             t
                                          
                                          =
                                          
                                             1
                                             
                                                2
                                                δ
                                                +
                                                1
                                             
                                          
                                          
                                             ∑
                                             
                                                
                                                   t
                                                   ′
                                                
                                                =
                                                t
                                                −
                                                δ
                                             
                                             
                                                t
                                                +
                                                δ
                                             
                                          
                                          
                                             (
                                             
                                                u
                                                
                                                   t
                                                   ′
                                                
                                             
                                             −
                                             
                                                μ
                                                t
                                             
                                             )
                                          
                                          
                                             
                                                (
                                                
                                                   u
                                                   
                                                      t
                                                      ′
                                                   
                                                
                                                −
                                                
                                                   μ
                                                   t
                                                
                                                )
                                             
                                             T
                                          
                                       
                                    
                                 
                              
                           
                        
                     with 
                        
                           
                              μ
                              t
                           
                           =
                           
                              1
                              
                                 2
                                 δ
                                 +
                                 1
                              
                           
                           
                              ∑
                              
                                 
                                    t
                                    ′
                                 
                                 =
                                 t
                                 −
                                 δ
                              
                              
                                 t
                                 +
                                 δ
                              
                           
                           
                              u
                              
                                 t
                                 ′
                              
                           
                        
                     .

                        
                           (31)
                           
                              
                                 
                                    
                                       
                                          
                                             Σ
                                             t
                                          
                                          ·
                                          
                                             v
                                             
                                                t
                                                ,
                                                i
                                             
                                          
                                          =
                                          
                                             λ
                                             
                                                t
                                                ,
                                                i
                                             
                                          
                                          ·
                                          
                                             v
                                             
                                                t
                                                ,
                                                i
                                             
                                          
                                          ,
                                          i
                                          ∈
                                          
                                             {
                                             1
                                             ,
                                             2
                                             }
                                          
                                       
                                    
                                 
                              
                           
                        
                     The eigenvector v
                     
                        t, i
                      with the larger corresponding eigenvalue points toward the direction of highest variance. The eigenvalues λ
                     
                        t, i
                      characterise the motion. If both values are similar, it is a curved motion, otherwise a line. In order to capture temporal variation on different levels, the feature vectors are composed of the eigenvalues and main eigenvectors, calculated over the tracked trajectory points of three different temporal windows with δ ∈ {4, 5, 6} for RWTH-PHOENIX-Weather and δ ∈ {8, 9, 10} for SIGNUM. Additionally, the position of the dominant hand with respect to the signer’s nose is added to the feature vector.

In DGS there are one- and two-handed signs. Two-handed signs either have a symmetric or anti-symmetric movement or the non-dominant hand serves as location for the dominant hand. In either case, the relative movement of the hands towards each other is a good indicator for this behaviour. We define Handedness features as the eigenvectors and eigenvalues of the movement of both hands relative to each other over multiple time windows of δ video frames. This corresponds to Eq. (30), with the relative distance between both hands rather than the hand position. δ has been optimised to be 4,5,6 for RWTH-PHOENIX-Weather and 8,9,10 for SIGNUM.


                     High-Level Face Features consist of seven continuous distance measurements across landmarks around the signer’s face, as described by Table 6
                     . They correspond to key locations on the cheeks and chin outlines, the nose ridge and nose base, the eyelids and eye corners, the eyebrow outlines and the lip and mouth corners. These measurements are based on the tracked landmarks as described in Section 5.2 and are expected to capture the information encoded in the non-manual parameters used in SL. To estimate the high-level mouth distances we project the registered shape and remove its global translation and rotation by means of the 3D PDM (refer to Section 5.2). Then, for each point subset given in Fig. 6, we estimate the corresponding local area-based measurement and normalise it between 0 and 1 according to the minimum and maximum values obtained during training. See Fig. 8 for a visualisation of these features.


                     Temporal Derivatives constitute a well known feature in ASR. They capture additional context being the temporal change of the features they are applied to. The derivatives denoted in the following as Δ for the first derivatives and ΔΔ for the second derivatives are calculated around the current frame Xt
                      as:

                        
                           (32)
                           
                              
                                 
                                    
                                       
                                          Δ
                                          
                                             (
                                             
                                                X
                                                t
                                             
                                             )
                                          
                                          =
                                          
                                             X
                                             
                                                t
                                                +
                                                1
                                             
                                          
                                          −
                                          
                                             X
                                             
                                                t
                                                −
                                                1
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (33)
                           
                              
                                 
                                    
                                       
                                          Δ
                                          Δ
                                          (
                                          
                                             X
                                             t
                                          
                                          )
                                       
                                    
                                    
                                       
                                          =
                                          
                                             X
                                             
                                                t
                                                +
                                                2
                                             
                                          
                                          −
                                          2
                                          
                                             X
                                             t
                                          
                                          +
                                          
                                             X
                                             
                                                t
                                                −
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     As discussed previously in this section, the system uses HOG-3D as well as other trajectory-based features to describe the different information channels of SL. Handedness, hand trajectory as well as high-level face features implicitly contain temporal derivatives and are therefore not used to extract additional delta features. HOG-3D features on the other hand, contain only quantised temporal information but do not encode the speed of the temporal change. Thus, Δ and ΔΔ features are only extracted from the HOG-3D features.

In Table 7
                         we present results using the advanced features introduced in the previous section. The features’ impact is evaluated on the signer dependent subsets of both corpora presented in Section 3. We can clearly see the positive impact of each added feature, which all help to reduce the WER from 43.5% with only HOG-3D to 38.6% with added dominant (right) hand trajectory and position, handedness, high-level face features and first and second order derivatives on the PHOENIX corpus. On SIGNUM the features reduce the error rate from 12.5% to 10.0% outperforming previous approaches (see Table 3). However, the derivatives do not improve the recognition. This may be explained by the controlled signing speed in SIGNUM as described in Section 3. Due to the staged nature of the corpus the artificial signing can be observed as rhythmic with consistent speed. Thus, features capturing this speed do not add additional discriminative information.

Comparing HOG-3D only results to the results obtained by PCA reduced hand-patch features (see Tables 4 and 5), HOG-3D features extracted from tracked locations outperform the PCA hand-patch features extracted from ground-truth annotation. This clearly shows the importance of noise robust features. HOG-3D features consist of spatial and temporal edges focusing on the shape of the hands.

The fact that each of the other individual features improves the recognition is important, as it underlines the multimodality of SL. This corresponds to sign linguists’ findings: The information in SL is perceived through manual and non manual channels simultaneously. The question how to best combine the features is still unsolved, a thorough analysis can be found in [22]. Only minor gain from asynchronous modelling is reported there. This is why we preferred a feature combination by stacking in the scope of this work. Stacking features together in an HMM framework bears a difficulty with respect to the feature weight. Each feature dimension adds to the final decision and its scaling with respect to the other dimensions is a detailed, but crucial factor determining possible reduction of WER. This constitutes a big difference to ASR systems, where the set of features is quite standard and lower dimensional. Feature Preprocessing plays, thus, a key role in our HMM approach. Therefore, we apply a global variance normalisation per dimension. Adaptive feature transformations (such as constrained maximum likelihood linear regression (CMLLR) presented in Section 8), linear discriminant analysis (LDA) or discriminative feature learning approaches, such as neural networks also help controlling this problem. The employed statistical modelling approach uses the Mahalanobis distance and diagonal covariance matrices (refer to Section 4 for details). This makes it crucial that the features are decorrelated, for which we use PCA.

The way we model the features crucially influences the system’s performance. An often neglected aspect of building statistical models for SL recognition tasks is how to model non-speech. Modelling non-speech in the context of ASLR, i.e. non-gesture, is a challenging task because it is not clear which parts of the temporal signal are not part of a sign. While in ASR the transition between words may be marked by a decline in speech volume, the transition between signs depends on both enclosing signs. For example consider the case of a sign ‘A’ ending its manual part with the dominant hand raised to the eye level of the signer and the following sign ‘B’ starting its manual component at waist height. In this case neither the movement from the ending location of sign ‘A’ to the starting location of sign ‘B’ nor the hand’s change in shape and orientation are part of either signs. Thus, the transition part called movement epenthesis should not be part of the learned statistical models for signs ‘A’ and ‘B’. If the movement epenthesis spans only a couple of time frames it can be compensated for by HMMs but in ‘real-life’ video footage this is often not the case.

Besides movement epenthesis effects, signers tend to switch hands while signing causing non-gesture effects for the models trained to recognise the manual aspects of the respective other hands.

In this section we provide insights about the question of how to model SL on three levels:

                        
                           •
                           Improving the HMM state-alignment by non-gesture garbage models.

Length model HMMs to account for length in whole sign models.

Account for co-articulation effects by adding threshold or transition model.


                        Fig. 9
                         shows the video frame to HMM state alignments for one sentence of the RWTH-PHOENIX-Weather corpus. On the left side without non-gesture models and on the right side using non-gesture models. The time in video frames is depicted on the x-axes with the ground truth glosses including the gloss/sign boundaries overlayed on the axis. The y-axis depicts the states of the individual HMM models. The blue circles represent that the frame in question has been aligned to this HMM state where the colour change in the background illustrates the time period that is aligned to the same state. The red straight line linking the origin of the plot to the top right corner is an optical aid not related to the alignment but illustrates the theoretical ideal alignment.

Comparing the left part to the right part in Fig. 9 one can see that the depicted alignment on the right side is closer to the optical aid representing an ideal alignment when the length modelling is perfect. Furthermore, the large ‘plateau’ areas in the alignment on the left side have vanished from the alignment indicating a better distribution of the data to the learned models. Finally, the non-gesture block on the left side of Fig. 9 indicated by the white blank in the ground truth gloss annotation has correctly been assigned to a non-gesture block. Non-gesture blocks for RWTH-PHOENIX-Weather have been inferred from ground truth annotation accounting for hand changes and non-gesture facial expressions, such as mimics.

Applying non-gesture garbage models to a recognition system using HOG-3D and movement trajectory features extracted from ground truth annotation of the hand positions, the recognition system result is improved from 42.1% to 39.8% WER for the signer dependent sub set of RWTH-PHOENIX-Weather. This underlines the importance of modelling non-gesture for ASLR.

The used non-gesture garbage modelling makes use of the fact that a subset of the RWTH-PHOENIX-Weather database is annotated on the sentence and the sign level. This allows to identify temporal gaps between signs and assign a garbage tag to these gaps. Furthermore, annotations include tags for the left vs. right hand, also allowing to add offhand specific tags for modelling. These kind of annotations are not available for the SIGNUM database, preventing the use of the proposed garbage models to the SIGNUM database. Nevertheless, results on SIGNUM are expected to improve, if a similar kind of garbage modelling is applied to it.

Length modelling is analysed to account for the variability of sign duration. Models incorporating the average length of signs corresponding to a certain gloss are compared to models having a constant length for all glosses.

In Table 8
                        
                         the impact of length modelling can be verified. To evaluate the impact of length modelling, it is compared to the baseline system using a standard 3–2 Bakis HMM. The number of states S is determined by half of the median of the total number N of running lengths l belonging to a certain gloss i. Only if this value is bigger than the shortest length l
                        
                           i, min reduced by 20%, then the number of states has to be adapted to ensure all training samples can reach the end state of the model. Refer to Eq. (34) for a mathematical description.

                           
                              (34)
                              
                                 
                                    
                                       
                                          
                                             
                                                S
                                                i
                                             
                                             =
                                             min
                                             
                                                (
                                                0.8
                                                ·
                                                
                                                   l
                                                   
                                                      i
                                                      ,
                                                      min
                                                   
                                                
                                                ,
                                                
                                                   1
                                                   2
                                                
                                                ·
                                                
                                                   
                                                      l
                                                      ˜
                                                   
                                                   i
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (35)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   l
                                                   i
                                                
                                                ˜
                                             
                                             :
                                             =
                                             
                                                {
                                                
                                                   
                                                      
                                                         
                                                            l
                                                            
                                                               i
                                                               ,
                                                               ⌈
                                                               
                                                                  N
                                                                  2
                                                               
                                                               ⌉
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            n
                                                            
                                                            odd
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               1
                                                               2
                                                            
                                                            
                                                               (
                                                               
                                                                  l
                                                                  
                                                                     i
                                                                     ,
                                                                     
                                                                        N
                                                                        2
                                                                     
                                                                  
                                                               
                                                               +
                                                               
                                                                  l
                                                                  
                                                                     i
                                                                     ,
                                                                     ⌈
                                                                     
                                                                        N
                                                                        2
                                                                     
                                                                     ⌉
                                                                  
                                                               
                                                               )
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            n
                                                            
                                                            even
                                                         
                                                      
                                                   
                                                
                                                ,
                                                
                                                
                                                   l
                                                   
                                                      i
                                                      ,
                                                      n
                                                   
                                                
                                                ≤
                                                
                                                   l
                                                   
                                                      i
                                                      ,
                                                      n
                                                      +
                                                      1
                                                   
                                                
                                                
                                                ∀
                                                
                                                n
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Referring to Table 8, on the single signer subset of RWTH-PHOENIX-Weather an absolute gain of more than 5% can be observed by using length modelling and basic PCA-reduced hand-patch features for the tracked dominant hand. SIGNUM does not show this behaviour, here the WER increases from 16.0% to 17.5% with length modelling. Similarly, for RWTH-PHOENIX-Weather multi-signer, the error rate increases with length modelling. Within the single signer setup of RWTH-PHOENIX-Weather gloss lengths have been manually annotated (all gloss boundaries throughout the corpus are annotated), whereas within SIGNUM and RWTH-PHOENIX-Weather2014 multi-signer they have been estimated from the recogniser state alignment. This fact is likely to account for the difference. It can be concluded that an accurate length modelling helps to improve recognition performance. Similar observations have been made in the early times of ASR before the transition from whole-word models to phoneme-based models.

SLs, particularly when looking at natural signing, contain a lot of variability. The preceding and following signs influence the starting position and the execution of the current sign. Also, noises in the recording material and errors in the manual annotation render the learning of clean and accurate models difficult.

In this subsection, we evaluate a method to better cope with noise in the data, particularly originating from movement epenthesis in SL. Similar to Yang et al. [74], we implemented a threshold model to account for outliers in the data, whenever they do not match the gloss model well enough. During Viterbi training, when searching for the optimal alignment between features 
                           
                              x
                              1
                              T
                           
                         and the HMM state sequence 
                           
                              
                                 s
                                 1
                                 N
                              
                              ,
                           
                         we allow a threshold garbage model to account for the input features by upper-bounding the log-likelihood score to the threshold value λ. However, the model showed no significant improvement in our large scale recognition pipeline.

Improvement could be achieved by learning a universal transition model, being a background HMM with a single state and separately optimised transition probabilities. During Viterbi training, this model has an empty pronunciation and can thus be inserted in between two signs to account for the movement epenthesis. As can be seen in Table 9, an improvement by 1.9% WER (58.3% → 56.4%) on the development set and 1.4% on the PHOENIX MS test set could be achieved.

ASLR is currently transitioning from signer specific systems trained on a single signer to systems capable of dealing with multiple signers. A requirement for building systems for multiple signers or even signer independent systems is a suitable amount of annotated training data for each of the signers in question.

Considering the multi-signer setups of SIGNUM and RWTH-PHOENIX-Weather (see Section 3), they benefit from the increased amount of training data. However, on the other hand, the varying signing styles of the different signers contribute to a higher inter-signer variability in addition to the strong intra-signer variability present also in the single signer corpora.

In the area of large vocabulary speech recognition, a common technique to address intra-signer variability is speaker adaptive training and speaker adaptation. Speaker adaptive training is a two pass training procedure in which the model trained in the first pass is adapted to the data. Constrained maximum likelihood linear regression (CMLLR) [25] allows to adapt the features to the learned model from the first pass and to re-train the whole system using the adapted features. To learn the necessary linear transformation one needs to know which speaker/signer performed which sentence and a time alignment of the individual feature frames to the states of the learned HMM. Both information is available for RWTH-PHOENIX-Weather and SIGNUM.

For this experiment, the feature evaluation from Table 7 has been re-evaluated using the multi-signer corpora. Table 10
                      subsumes the results for RWTH-PHOENIX-Weather and SIGNUM multi-signer for adding each additional feature, in a standard approach (column ‘no CMLLR’) and with speaker adaptive training and CMLLR (column ‘CMLLR’). All parameters have been optimised on the development set only. HOG-3D, movement trajectory and handedness features have been extracted using tracking results obtained via the DPT system (Section 5). All features have been variance normalised and individually PCA reduced to maintain 99.5% of their variance. This decorrelation has been seen to be crucial in order to successfully apply CMLLR.


                     Standard no-CMMLR results obtained on RWTH-PHOENIX-Weather multi-signer improve from 58.1% WER with the HOG-3D features to 55.6% with added trajectory, handedness and highlevel face features on the test set. Reported single signer results (refer to Table 7) have been more than 20% absolute better. However, recognition results on both sets are not comparable as (a) annotated ground truth object locations are used for signer-dependent experiments in Table 7 instead of automatic DPT tracking, and (b) length modelling is done using annotated gloss lengths for signer dependent experiments while they are estimated from training state alignments in this section. While these error sources are difficult to avoid, it gives a realistic estimate of the system performance when deployed in a TV studio (e.g. providing automatic subtitling). Furthermore, the signers present in RWTH-PHOENIX-Weather are trained hearing interpreters hailing from different areas of Germany. They differ in pronunciation and show dialectic differences.

The overall trend found in the previous section with regard to the impact of individual features is preserved with the exception of adding the derivatives. Both the development and the test set show similar performance while the results on the test set are slightly better than the results obtained on the development set showing that the learned models are able to generalise to unseen data. This also applies to comparable ‘no CMLLR’ results on the SIGNUM multi-signer set as shown in Table 11
                     . Here, the WER decreases from 19.1% to 16.4% on the 25 signer corpus. This underlines the fact that the RWTH-PHOENIX-Weather database represents a bigger challenge than the SIGNUM database. This is because the data in the RWTH-PHOENIX-Weather database constitute natural signing, which has not been controlled particularly for research purposes.

The CMLLR results shown in Table 10 denote the improvement achieved by this linear speaker-based transformation. The lowest error rate with HOG-3D, trajectory, handedness and high-level face features reaches 53.0% on the PHOENIX MS test set, while being 2.6% better than without CMLLR. Note that the speakers have been manually identified during recognition. Apparently, CMLLR does not work as well with the trajectory and handedness features. The added trajectory features show only an improvement of 0.2%, reaching a higher WER than the HOG-3D alone and adding handedness increases the error by 0.5% on the test set after the transformation. However, 55.0% on the dev set and 53.0% on the test set represent the best results published so far.


                     Fig. 10
                      shows the WERs per signer of the best RWTH-PHOENIX-Weather multi-signer setup (being 55.6% vs. 53.0%). Note that the error rate decreases in all cases but for Signers #2 and #6. The reason is that those two signers occur seldomly in the training set ( < 1%) (see Fig. 4) and thus CMLLR transformation matrices cannot be reliably estimated.

On the SIGNUM data set CMLLR improved the HOG-3D result from 19.1% (see Table 11) to 18.6%.

ASLR systems employ a statistical LM in addition to the HMM-based visual models as a knowledge source. The LM models the probability of a sign or word occurring in the context of other signs and is learned from text data. In ASR the LM is learned from millions of running sentences in the target language and domain of the recognition system. Since SLs are purely visual languages without a normed or even agreed writing system, the LM can only be learned from the annotated trained data of the corpus under consideration. The low amount of training data for the LM reduces the power of the LM during ASLR because the majority of glosses will only be seen once or twice in any given context.

Statistical language modelling of SLs suffers from the low amount of available textual training data, and high sparsity in the sense of a low frequency of the vocabulary entries being seen in any given SL sentence. One way to improve the consistency and frequency in which a specific gloss is seen in context of other glosses is to introduce gloss classes. During training of the LM, the gloss in question is replaced by its class effectively pooling all occurrences of class members into one context n-gram. For example, the gloss sequences MORGEN 22 GRAD, MORGEN 4 GRAD, and MORGEN 12 GRAD result in different 3-grams with a support of one each. Conversely, using a class for numbers the three gloss sequences transform into MORGEN <number> GRAD leading to one 3-gram with a support of three.

These classes can be inferred automatically from training data by clustering glosses according to context. Creating classes automatically suffers from the underlying data sparseness problem preventing its application to current SL corpora.

Another way to define classes is by performing a manual analysis of the recognition errors of any given recognition system. In case of the system setup described in Section 7.1 achieving 39.4% (HOG-3D + RH Traj/Place + Handedness), 3.8% absolute WER of all recognition errors are due to wrongly recognised numbers. Numbers occur in the description of temperatures, dates and altitudes. Furthermore, 2.2% absolute of all errors can be attributed to falsely recognised orientation descriptions such as NORD or NORDWEST (north and north-west).


                        Table 12
                         shows the impact of augmenting a 3-gram LM using Kneser–Ney discounting by classes for numbers and orientations for the single signer subset of RWTH-PHOENIX-Weather. The domain of weather forecasts featured in the RWTH-PHOENIX-Weather corpus is structured and lends itself well to the class LM approach.

Adding classes to the LM improves in both cases the perplexity of the LM. The perplexity, as defined in Eq. (36), is an inverse probability between how many classes the model chooses on average to hypothesise every word of a text of length N.

                           
                              (36)
                              
                                 
                                    
                                       
                                          
                                             
                                                Perplexity
                                             
                                             =
                                             p
                                             
                                                
                                                   (
                                                   
                                                      w
                                                      1
                                                      N
                                                   
                                                   )
                                                
                                                
                                                   −
                                                   
                                                      1
                                                      N
                                                   
                                                
                                             
                                             =
                                             
                                                
                                                   [
                                                   
                                                      ∏
                                                      
                                                         n
                                                         =
                                                         1
                                                      
                                                      N
                                                   
                                                   
                                                      (
                                                      p
                                                   
                                                   
                                                      (
                                                      
                                                         w
                                                         n
                                                      
                                                      |
                                                      
                                                         h
                                                         n
                                                      
                                                      )
                                                   
                                                   ]
                                                
                                                
                                                   −
                                                   
                                                      1
                                                      N
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Adding only numbers or orientations to the LM improves the LM perplexity by more than 10% relative leading to improvements in the ASLR performance. Adding both classes to the LM improves the perplexity by more than 25% relative leading to an overall recognition improvement of 1.2%. Applying the class LM (numbers and orientations) on top of the proposed system using high-level face features, 34.3% WER (20.5% deletions/1.8% insertions) is achieved. In case of added temporal derivatives no further gain is observed.

Repeating the same process for the multi-signer setup of RWTH-PHOENIX-Weather the LM perplexity is again reduced from 47.9 without gloss classes to 38.2 using a class for numbers and finally to 33.8 by using both numbers and orientations as classes. In contrast to the signer dependent subset, no improvement in recognition performance is observed for the multi-signer setup. Inspecting the errors made by the system with and without class LM it is observable that while the right class (e.g. orientations) from LM perspective is predicted by the ASLR system, the visual model proposes the wrong sign (e.g. NORTH instead of SOUTH). Thus, potential improvements by the class LM are obscured by the lower discriminative power of the visual model.

Class LMs are not considered for the SIGNUM database because of the artificial nature of the sentence construction.

In this paper we have shown our recent advances in system design for ASLR. We evaluated our approach on two large publicly available continuous SL data sets representing lab-data (SIGNUM database: 25 signer, 455 sign vocabulary, 19k sentence) and unconstrained ‘real-life’ SL (RWTH-PHOENIX-Weather database 9 signer, 1081 sign vocabulary, 7k sentences) reflecting the community’s moving from artificial lab-generated data to ‘real-life’ data. Compared to the current best published results, we are able to improve recognition on lab-data from 10.7% WER to 10.0% for a single signer and from 21.4% down to 16.4% for a multi-signer setup. On the challenging ‘real-life’ data set we improve the previously best known result of 38.6% WER to 33.4% for a single signer and set a new best result for the PHOENIX multi-signer setup at 53.0% WER.

In numerous detailed ASLR experiments targetting features, visual modelling, signer-dependency and language modelling, we show the impact and benefit of

                        
                           •
                           tracking of the hands and facial landmarks,

multimodal SL features describing hand shape, hand position and movement, inter-hand-relation and detailed facial parameters, as well as temporal derivatives,

tackling ASLR jointly with hand and face features,

non-gesture-models, length modelling and universal transition models,

CMLLR as strategy to cope with inter-signer variation in multi-signer corpora and

class language modelling.

To sum up, we showed that the statistical approach works for SL recognition and that the results remain consistent with what is expected, even on larger corpora of continuous ‘real-life’ signing. Applying techniques from speech recognition is useful, as long as the particularities of SL are being taken care of. We present guidelines to open up the field for newcomers who can benefit from the insights presented here jointly with public access to our large-vocabulary continuous SL corpus RWTH-PHOENIX-Weather.

@&#FUTURE WORK@&#

ASLR is still a brittle technology in the sense of the used amounts of data and modelling techniques. Developments in the area of consumer cameras and the advent consumer priced 2.5D camera systems such as Microsoft’s Kinect 2.0 system promise to benefit ASLR systems greatly by reducing the complexity of object tracking and feature extraction. Accessing depth information as an additional knowledge source, ASLR can be used to analyse the usage of the signing space in front of a signer allowing to improve recognition performance.

The increase in SL corpora size over the last years makes findings for ASLR more reliable fostering research into multi-signer and even signer independent ASLR. Furthermore, advances in SL linguistics coupled with bigger corpora will allow to investigate sub-sign units comparable to the idea of phonemes for spoken languages. Such sub-sign units will allow the application of modelling techniques from conventional ASR that are currently not transferable to ASLR.

In terms of features for SLs, neural networks and especially deep neural networks show promising results in the area of conventional ASR allowing to automatically learn optimal features for a given language.

@&#REFERENCES@&#

