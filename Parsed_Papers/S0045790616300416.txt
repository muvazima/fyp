@&#MAIN-TITLE@&#Kernel based approach for accurate surface estimation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The problem of detecting the surface of an unknown arbitrarily-shaped scene from a set of points is proposed.


                        
                        
                           
                           Range data is obtained from in-house developed Laser range scanner.


                        
                        
                           
                           The surface estimation problem is described as a max-margin based formulation of a kernel function and solving the objective function using sub-gradient method.


                        
                        
                           
                           Additional geometric ray based information is used to eliminate the unnecessary bumps on the surface and increase the precision.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Laser range scanner

Max-margin formulation

Surface estimation

Kernel

Sub-gradient method

@&#ABSTRACT@&#


               
               
                  Accurate surface estimation is a critical step for autonomous robot navigation on a rough terrain. In this paper, we present a new method for estimating the surface of an unknown arbitrarily shaped terrain from the range data. The terrain modeling problem is generally formulated as the estimation of a function whose zero-set corresponds to the surface to be reconstructed. A Laser range scanner has been built for acquisition of range data. The range data from the scanner samples the terrain unevenly, and is more sparse for distant regions from the sensor. The paper describes the surface estimation problem as a max-margin based formulation of a non-stationary kernel function and minimizes the objective function using sub-gradient method. Unlike other methods, additional geometric ray based information is used to eliminate the unnecessary bumps on the surface and increase the precision. The experimental results validate the robustness of the proposed approach.
               
            

@&#INTRODUCTION@&#

Accurate terrain reconstruction is a critical and challenging component to represent the distribution of surface elevation for mobile robot navigation in an unknown, rough and cluttered environment. Successful mobile robot navigation requires an efficient and high quality representation of the surface because of complication arising out of uncertainty, incompleteness and highly unstructured terrain. Of these, uncertainty and incompleteness are virtually universal in mobile robotics because the sensor capabilities are limited. The problem is of interest to a number of applications such as mining, path planning, space exploration, geological surveys and preparation, and different terrain analysis. In case of Laser scanner, the distribution of range data points decays rapidly away from the range sensor, and there may be vast surface regions that return no scanned points at all. The variable resolution of range data points is inevitable due to use of static scanning patterns and discrete sampling. Additionally, in the rough outdoor terrain, complex surface geometry, uneven ground, and the presence of inclines worsens the problem of estimation due to occlusions.

Several methods are known to simplify the problem considerably by representing the terrain as a flat, 2D cost map, but this is inadequate for modeling significantly uneven terrain because hills and rough surfaces are not accurately represented, compelling the vehicle to drive at very low speeds and make conservative judgments. However, an explicit 3D model of the environment based on 3D data points and meshes has limitations when dealing with structurally complex and fine features (rubble) or incomplete range data of the environments. Current methods use interpolation to create a continuous mesh surface where the scan is sparse, but this can be very difficult if the terrain is complex as the interpolation will gloss over the fine detail. The alternative approach is implicit surface modeling, which generates internally consistent 3D models directly from numerical data and structural measurements by a single mathematical volume function (which is akin to surface fitting). The main advantage of implicit surface modeling is that it allows to robustly generate the surface from different types of data, such as structurally complex, incomplete or noisy range data of the environments. The function is computed by spatial interpolation of range data points to define isosurfaces, which are represented as triangulated meshes with a user-defined resolution. In general, isosurfaces are 3D surfaces that embody 3D points of a constant value within a defined volume space. The zero set of this function 
                        
                           f
                           
                              (
                              x
                              ,
                              y
                              ,
                              z
                              )
                           
                           =
                           0
                        
                      corresponds to the surface. In this paper, the terrain is represented by a continuous elevation function for implicit surface reconstruction, which enables smooth and effective extrapolation for hole filling in the scanned range samples. Using the implicit surface model, the characteristic of the ground for the mobile robot can be predicted more precisely, allowing for faster autonomous driving and longer range path planning. In the proposed method, the surface is estimated using non-stationary kernel functions, which allow nonlinear, complex solutions. The kernel functions are constrained by both positive and negative information from the range sensor.

A non-stationary, isotropic kernel formulation provides flexibility by varying the smoothness of the elevation function according to the spatial data density and uncertainty. Large lengthscale covariances may be preferable for smoothing noisy data points from long-range sensors or for smoothly interpolating sparsely sampled regions whereas small covariances are required for accurate surface estimation where range data is accurate and dense. The problem with the use of a fixed lengthscale covariance, is unavoidable when reconstructing rough surface from range data which is unevenly sampled, as in the case of mobile robots, and hence a non-stationary formulation is suggested. We have followed the formulation of Paciorek and Schervish [1,2], who have introduced a class of non-stationary covariance functions for spatial modeling (e.g., climate data). Spatial surfaces whose variability fluctuates with location have been modeled using a non-stationary spatially changing covariance. Rather than learning the best covariances through Gaussian process models [1,2], we select the variable lengthscales by external cues, such as sensor distance and data distribution. This technique is efficient, intuitive and allows real-time surface reconstruction. The paper presents a new method for the surface fitting problem by formulating it as a classification task of range data using a non-stationary kernel function. In the surface fitting problem, a given set of 3D points with associated labels as interior or exterior of the surface, is considered. In this technique, the surface estimation task lends itself to a max-margin based representation, allowing non-linear/non-parametric and higher dimension surfaces to be computed using the non-stationary kernel function. In addition to the above technique, we also incorporate the complete geometric ray-based (visibility) information about the range data points. Generally, when the range data points are sampled from a range sensor, the information about ray connecting the sampled points to their range sensor location is implicitly known. By incorporating this information as a set of multiple constraints set into the max-margin framework, an enhanced solution to the surface estimation problem can be achieved. Such a framework formulation is attractive because of the stability of the obtained solutions and the range of the functional forms that could be incorporated. We introduce the visibility constraint into mathematical framework and determine a rule for functional sub-gradient descent optimization, yielding a surface estimate with high accuracy which works on different types of data sets. In this paper, the proposed surface reconstruction method is tested on range data which is obtained from the in-house developed Laser Range Scanner (LRS).

The remainder of this paper is organized as follows: Section 2 discusses the related work. Section 3 describes the proposed method in detail. Section 4 presents the experimental results and finally, we conclude the paper in Section 5.

@&#RELATED WORK@&#

A detailed overview of methods used for terrain modeling has been given by Hufentobler [3]. The explicit elevation maps (or “elevation grids”) are a standard technique for representing dense terrain surfaces. Several strategies exist for generating terrain surfaces, from mesh algorithms to statistical techniques to interpolation (Pfaff and Burgard [4], Hygounenc et al.[5], Jaspers and Wuensche [6]). Triebel et al. [7] have proposed an extension of the elevation maps towards multiple terrain surfaces. The multilevel surface maps extend the opportunity to model terrain with more than one traversal level such as those having overhanging structures and vertical objects. Yamaura et al. [8] have introduced a new technique to reconstruct the explicit surface of an object in terms of a C
                     1 continuous B-spline function above the xy-plane based on the surface normal vectors of the object. The explicit methods use interpolation to generate a continuous mesh surface, but it can be very difficult if the terrain is complex and the range data is sparse. Other approaches to model the surface are an implicit modeling technique. Some popular methods use local nature for deducing the implicit functions, such as level set models [9], local surface models [10], geometric flow [11] or implicit surfaces interpolated from polygon data [12,13]. Due to the use of the local properties for terrain analysis, most of the above mentioned methods often need normal information about the destination surface in order to produce the implicit surfaces correctly. Funk and Dooley [14] have presented a robust 3D scene modeling technique which has predicated the observation that most objects comprise of only a small set of primitives that is generated by a combination of sparse approximation techniques from the compressive sensing domain along with surface rendering approaches from computer graphics.

The kernel based methods provide another solution for implicit terrain modeling [15], the implicit models basically fit a radial basis function, either fully supported [16] or compactly supported functions [17] on range datasets. These methods usually require surface normal information, except in the recent research works [18]. The method computes an implicit model of a hyper surface which is given only by a finite sampling. Yguel et al. [19] have presented the use of sparse wavelets for 3D modeling of the environment from range data, and Fournier et al. [20] have used an octree representation to efficiently model a 3D world model. Plagemann et al. [21] have used the research work done by Paciorek and Schervish [22,23] and successfully applied Gaussian process regression to the problem of surface reconstruction of rough terrain, although their method is computationally expensive and has not been applied to large range datasets [21,24]. In the above, a probabilistic method based on Gaussian process regression which provides surface models to be learned and updated efficiently using sparse approximation techniques by considering issues such as iterative adaptation, computational constraints, and accurate modeling of local discontinuity has been presented. Lang et al. [24] have presented a well-established Gaussian process regression method for terrain modeling, which utilizes non-stationary covariance functions to locally adapt the structure of the range data. The authors have achieved strong smoothing in plain areas and along edges, and at the same time preserve edges and corners and the derived model generates predictive height distributions for arbitrary locations of the terrain, i.e., fills gaps in the data. Our approach utilizes a kernel based technique as well, but we propose an iterative algorithm that exploits ray based information to fit basis functions to compute a system of constraints. The terrain modeling using ray based (or visibility) constraints has hardly been explored in mobile robotics. First Kutulakos and Seitz [25] presented a space carving algorithm which uses visibility information to generate the 3D model of the scene from calibrated images, but this technique has not been adopted by machine vision community. Singh et al. [26] have presented a new method for rough terrain estimation of Laser scanner data using ray based information. Hadsell et al. [27] have presented an online kernel based learning method to estimate a continuous surface over the region of interest while supplying upper and lower bounds on that surface. The authors have incorporated visibility constraints into a reproducing kernel Hilbert space (RKHS) framework rather than adopt a voxel based approach to generates a continuous surface of the range data.

@&#PROPOSED METHOD@&#

In this section, we first provide a brief description of the Laser Range Scanner (LRS). Next, the Kernel based max-margin approach for accurate, realistic, and fast 3D representation of the terrain is illustrated.

In this section, we describe the working of 3D structured light system for acquisition of 3D information (range data) of the environment. Fig. 1
                         shows the Laser range scanner which is developed in-house robotics laboratory. The Laser scanner is made of a CCD camera, a Diode Red Laser with cylindrical lens as a line projector, a bipolar stepper motor, an Atmega 16 microcontroller, a microstepping motor driver (A4988) and two XigBee for RX/TX communication units. The camera and Laser are mounted on an aluminum beam, with the Laser at the center and the camera at the offset (left) position. This entire arrangement is then mounted on the stepper motor. The stepper motor can rotate this arrangement to cover the terrain through an angle of 
                           
                              360
                              ∘
                           
                        . In the experiments, the angle of rotation is limited to 
                           
                              120
                              ∘
                           
                        . The Laser (structured) light is passed through a cylindrical lens, that diverges the Laser dot into a thin fan beam that produces a Laser line on the terrain and the camera captures this Laser line profile on the surface. As the Laser line pattern moves over the object surface, the camera acquires the images of pattern that has been distorted by reflection from the terrain. In order to acquire the 3D data of the terrain in numerical terms, the range scanner is first calibrated by observing from the camera location a calibration plane (checker board plane) whose geometry is accurately known in the 3D space. The relative pose between the Laser and the camera of range scanner is automatically determined by taking a single view of the terrain. The range information of the unstructured terrain is determined according to the distortion of the Laser light stripe. At the end, we assemble all the collected sampled line profiles in the common reference frame to generate a complete 3D data of the scanned surface. The LRS provides accurate range measurements over the large angular field of terrain and is capable of an angular resolution of 
                           
                              0
                              .
                              
                                 1125
                                 ∘
                              
                           
                        . It produces high-resolution range datasets of the environment. Due to hardware design limitations, the total distance covered by the range sensor is 2–2.50 meters over an angular range of 
                           
                              360
                              ∘
                           
                        . The viewing distance of the range sensor can be increased by restructuring the position of the camera on the aluminum chassis. The major advantages of Laser range scanner are that it gives accurate 3D data, has a very high angular resolution, and sidesteps correspondence issue that challenges many triangulation approaches because of the use of structured light. Its disadvantage is the large scanning time due to hardware constraints (i.e., fixed setup).

We have a set of points of the form 
                           
                              U
                              =
                              
                                 {
                                 
                                    (
                                    
                                       u
                                       1
                                    
                                    ,
                                    
                                       u
                                       2
                                    
                                    ,
                                    
                                       u
                                       3
                                    
                                    ,
                                    ⋯
                                    
                                       u
                                       n
                                    
                                    )
                                 
                                 }
                              
                              ⊂
                              
                                 R
                                 d
                              
                              ,
                           
                         where each ui
                         is a data sample lying on the hyper surface and the range sensor is located at c ∈ Rd
                        . Given the set of range data points, we define a set 
                           
                              
                                 
                                    {
                                    
                                       (
                                       
                                          x
                                          i
                                       
                                       ,
                                       
                                          y
                                          i
                                       
                                       )
                                    
                                    }
                                 
                                 
                                    i
                                    =
                                    1
                                 
                                 n
                              
                              ∈
                              X
                              ×
                              Y
                           
                         of the labeled points xi
                         ∈ Rd
                         with the associated labels yi
                         ∈ { ± 1}, where xi
                         is the interior to the hyper-plane of interest if 
                           
                              
                                 y
                                 i
                              
                              =
                              1
                           
                         and exterior if 
                           
                              
                                 y
                                 i
                              
                              =
                              −
                              1
                           
                        . The points xi
                         are defined along the ray joining 
                           
                              
                                 u
                                 i
                                 ′
                              
                              s
                           
                         to c as shown in Fig. 2
                        . The aim is to learn the function (f) that maps the data points to their labels f: X → Y. The zero set of this function 
                           
                              
                                 f
                                 
                                    −
                                    1
                                 
                              
                              
                                 (
                                 0
                                 )
                              
                           
                         represents the surface that needs to be estimated. The output function (f) of the learning algorithm is generally referred as an hypothesis, and the set of all possible hypothesis is represented by 
                           H
                        . We assume that the hypothesis 
                           H
                         is in a reproducing kernel Hilbert space (RKHS) [28]. It means that there exists a kernel k: X × X → R and an inner product 
                           
                              <
                              .
                              ,
                              .
                              
                                 >
                                 H
                              
                           
                         such that k has a reproducing property, i.e.,

                           
                              (1)
                              
                                 
                                    
                                       
                                          
                                             
                                                〈
                                                f
                                                ,
                                                k
                                                (
                                                x
                                                ,
                                                .
                                                )
                                                〉
                                             
                                             H
                                          
                                       
                                       
                                          
                                             =
                                             f
                                             (
                                             x
                                             )
                                             
                                             
                                             ∀
                                             x
                                             ∈
                                             H
                                          
                                       
                                    
                                    
                                       
                                          
                                             ∥
                                             f
                                             ∥
                                          
                                       
                                       
                                          
                                             =
                                             
                                                
                                                   〈
                                                   f
                                                   ,
                                                   f
                                                   〉
                                                
                                                
                                                   H
                                                
                                                
                                                   1
                                                   2
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        and all 
                           
                              f
                              ∈
                              H
                           
                         are linear combinations of kernel functions. Given the above notations, we formulate the following optimization problem with slack variable(ζi
                        ):

                           
                              (2)
                              
                                 
                                    
                                       min
                                       
                                       
                                          λ
                                          2
                                       
                                       
                                          
                                             ∥
                                             f
                                             ∥
                                          
                                          
                                             H
                                          
                                          2
                                       
                                       +
                                       
                                          1
                                          N
                                       
                                       
                                          ∑
                                          i
                                       
                                       
                                          ζ
                                          i
                                       
                                       
                                       
                                       subject
                                       
                                       to
                                    
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       
                                          
                                             f
                                             (
                                             
                                                x
                                                i
                                             
                                             )
                                          
                                       
                                       
                                          
                                             ≥
                                             1
                                             −
                                             
                                                ζ
                                                i
                                                +
                                             
                                             
                                             
                                             if
                                             
                                             
                                                y
                                                i
                                             
                                             =
                                             1
                                          
                                       
                                    
                                    
                                       
                                          
                                             max
                                             f
                                             (
                                             
                                                x
                                                i
                                             
                                             )
                                          
                                       
                                       
                                          
                                             ≤
                                             −
                                             1
                                             +
                                             
                                                ζ
                                                i
                                                −
                                             
                                             
                                             if
                                             
                                             
                                                y
                                                i
                                             
                                             =
                                             −
                                             1
                                          
                                       
                                    
                                 
                              
                           
                        where λ ≥ 0 is a hyper parameter that trades off constraint violations for maximization of margin. Finally, we observe that the constraints in the above convex equations are tight (i.e., equality holds at optimum) so we can apply them directly into the objective function. Doing so, we formulate an unconstrained optimization problem as the following:

                           
                              (4)
                              
                                 
                                    
                                       min
                                       
                                       
                                       L
                                       
                                          (
                                          x
                                          ,
                                          y
                                          ,
                                          f
                                          )
                                       
                                       ≡
                                       min
                                       
                                       
                                          λ
                                          2
                                       
                                       
                                          
                                             ∥
                                             f
                                             ∥
                                          
                                          
                                             H
                                          
                                          2
                                       
                                       +
                                       
                                          1
                                          N
                                       
                                       
                                          ∑
                                          i
                                       
                                       r
                                       
                                          (
                                          
                                             x
                                             i
                                          
                                          ,
                                          
                                             y
                                             i
                                          
                                          ,
                                          f
                                          
                                             (
                                             
                                                x
                                                i
                                             
                                             )
                                          
                                          )
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    r
                                    
                                       (
                                       
                                          x
                                          i
                                       
                                       ,
                                       
                                          y
                                          i
                                       
                                       ,
                                       f
                                       
                                          (
                                          
                                             x
                                             i
                                          
                                          )
                                       
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   max
                                                   
                                                      (
                                                      0
                                                      ,
                                                      max
                                                      
                                                         (
                                                         f
                                                         (
                                                         
                                                            x
                                                            i
                                                         
                                                         )
                                                         +
                                                         1
                                                         )
                                                      
                                                      )
                                                   
                                                   ,
                                                
                                             
                                             
                                                
                                                   if
                                                   
                                                   
                                                      y
                                                      i
                                                   
                                                   =
                                                   −
                                                   1
                                                
                                             
                                          
                                          
                                             
                                                
                                                   max
                                                   
                                                      (
                                                      0
                                                      ,
                                                      1
                                                      −
                                                      f
                                                      (
                                                      
                                                         x
                                                         i
                                                      
                                                      )
                                                      )
                                                   
                                                   ,
                                                
                                             
                                             
                                                
                                                   if
                                                   
                                                   
                                                      y
                                                      i
                                                   
                                                   =
                                                   1
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        Eq. (4) characterizes the optimization problem of surface estimation. Therefore, we have transformed an optimization problem with a convex objective function and a combination of linear and nonlinear (i.e., max operator) constraints into an equivalent implicit convex optimization problem. In order to solve this problem for rough and complex surfaces, we use a kernel formulation by which distances between points can be computed in a highly non-linear, high-dimensional feature space without actually computing the coordinates of the data points in higher dimension feature space, since any continuous, symmetric, positive semi-definite kernel function k(x
                        
                           i
                        , x
                        
                           j
                        ) can be expressed as a dot product in a higher dimensional space. The kernel function is a hypothesis in RKHS and can be expressed by its expansion as [28]
                        
                           
                              (6)
                              
                                 
                                    f
                                    
                                       (
                                       x
                                       )
                                    
                                    =
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       α
                                       i
                                    
                                    k
                                    
                                       (
                                       
                                          x
                                          i
                                       
                                       ,
                                       x
                                       )
                                    
                                    
                                    x
                                    ∈
                                    X
                                 
                              
                           
                        where k(., .) is radial basis function and α are learned coefficients. An efficient, finite support radial basis function (i.e., Wu kernel function) k(., .) has been chosen (as shown in Fig. 3
                        ),

                           
                              (7)
                              
                                 
                                    k
                                    
                                       (
                                       
                                          x
                                          i
                                       
                                       ,
                                       
                                          x
                                          j
                                       
                                       )
                                    
                                    =
                                    k
                                    
                                       (
                                       ρ
                                       (
                                       
                                          x
                                          i
                                       
                                       ,
                                       
                                          x
                                          j
                                       
                                       )
                                       )
                                    
                                    =
                                    
                                       
                                          (
                                          1
                                          −
                                          ρ
                                          )
                                       
                                       +
                                       4
                                    
                                    
                                       (
                                       4
                                       +
                                       16
                                       ρ
                                       +
                                       12
                                       
                                          ρ
                                          2
                                       
                                       +
                                       3
                                       
                                          ρ
                                          3
                                       
                                       )
                                    
                                 
                              
                           
                        where

                           
                              (8)
                              
                                 
                                    ρ
                                    
                                       (
                                       
                                          x
                                          i
                                       
                                       ,
                                       
                                          x
                                          j
                                       
                                       )
                                    
                                    =
                                    
                                       
                                          
                                             ∥
                                          
                                          
                                             x
                                             i
                                          
                                          −
                                          
                                             x
                                             j
                                          
                                          
                                             ∥
                                          
                                       
                                       σ
                                    
                                 
                              
                           
                        and σ is the lengthscale of basis function. The kernel function k(., .) has been chosen over other possible radial basis functions as suggested by Schaback [29] and emprical success of Wu polynomial function for surface modeling [15].

The euclidean distance function stated in Eq. (7) is a stationary, isotropic function whose lengthscale (σ) is fixed and the covariance is symmetrical, or isotropic, such as in any radial basis function (rbf). In order to allow the covariance to change over the spatial domain, a non-stationary, positive definite kernel function can be used. Higdon et al. [23] have formulated such a kernel function, that has been latter advanced and applied by others in different contexts [22,24]. A nonstationary covariance function is obtained by convolving kernel functions centered at two different spatial locations in any euclidean space 
                           
                              
                                 R
                                 p
                              
                              ,
                           
                        
                        
                           
                              p
                              =
                              1
                              ,
                              2
                              ,
                              .
                              .
                              .
                           
                         
                        [22]:

                           
                              (9)
                              
                                 
                                    
                                       C
                                       
                                          n
                                          s
                                       
                                    
                                    
                                       (
                                       
                                          x
                                          i
                                       
                                       ,
                                       
                                          x
                                          j
                                       
                                       )
                                    
                                    =
                                    
                                       ∫
                                       
                                          R
                                          2
                                       
                                    
                                    
                                       k
                                       
                                          x
                                          i
                                       
                                    
                                    
                                       (
                                       u
                                       )
                                    
                                    
                                       k
                                       
                                          x
                                          j
                                       
                                    
                                    
                                       (
                                       u
                                       )
                                    
                                    d
                                    u
                                 
                              
                           
                        where x
                        
                           i
                        , x
                        
                           j
                         and u are locations in the space R
                        2, and k
                        
                           x
                        (., .) is a kernel function centered at x. In fact, a non-stationary correlation function can be derived from any stationary correlation function which is positive definite: If Rst
                        (τ) is an isotropic positive definite correlation function on 
                           
                              
                                 R
                                 p
                              
                              ,
                              p
                              =
                              1
                              ,
                              2
                              ,
                              .
                              .
                              ,
                           
                         then a non-stationary correlation function Rns
                        (., .) which is also positive definite [22]
                        
                           
                              (10)
                              
                                 
                                    
                                       R
                                       
                                          n
                                          s
                                       
                                    
                                    
                                       (
                                       
                                          x
                                          i
                                       
                                       ,
                                       
                                          x
                                          j
                                       
                                       )
                                    
                                    =
                                    
                                       C
                                       
                                          i
                                          j
                                       
                                    
                                    
                                       R
                                       
                                          s
                                          t
                                       
                                    
                                    
                                       (
                                       
                                          
                                             Q
                                             
                                                i
                                                j
                                             
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        where covariance function (Cij
                        ) is defined as

                           
                              (11)
                              
                                 
                                    
                                       (
                                       
                                          C
                                          
                                             i
                                             j
                                          
                                       
                                       )
                                    
                                    =
                                    
                                       
                                          
                                             2
                                             
                                                p
                                                2
                                             
                                          
                                          
                                             |
                                          
                                          
                                             Σ
                                             i
                                          
                                          
                                             
                                                |
                                             
                                             
                                                1
                                                4
                                             
                                          
                                          
                                             
                                                |
                                                
                                                   Σ
                                                   j
                                                
                                                |
                                             
                                             
                                                1
                                                4
                                             
                                          
                                       
                                       
                                          
                                             |
                                          
                                          
                                             Σ
                                             i
                                          
                                          +
                                          
                                             Σ
                                             j
                                          
                                          
                                             
                                                |
                                             
                                             
                                                1
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           
                        In this correlation function, x
                        
                           i
                         and x
                        
                           j
                         are related with location dependent covariance matrices Σi
                         and Σj
                         and Qij
                         is a quadratic form:

                           
                              (12)
                              
                                 
                                    
                                       Q
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    
                                       (
                                       
                                          x
                                          i
                                       
                                       −
                                       
                                          x
                                          j
                                       
                                       )
                                    
                                    
                                       
                                          (
                                          
                                             
                                                
                                                   Σ
                                                   i
                                                
                                                +
                                                
                                                   Σ
                                                   j
                                                
                                             
                                             2
                                          
                                          )
                                       
                                       
                                          −
                                          1
                                       
                                    
                                    
                                       
                                          (
                                          
                                             x
                                             i
                                          
                                          −
                                          
                                             x
                                             j
                                          
                                          )
                                       
                                       T
                                    
                                 
                              
                           
                        Now applying this formulation to the Wu polynomial function for generating the non-stationary kernel function

                           
                              (13)
                              
                                 
                                    
                                       k
                                       
                                          n
                                          s
                                       
                                    
                                    
                                       (
                                       
                                          x
                                          i
                                       
                                       ,
                                       
                                          x
                                          j
                                       
                                       )
                                    
                                    =
                                    
                                       C
                                       
                                          i
                                          j
                                       
                                    
                                    
                                       k
                                       
                                          s
                                          t
                                       
                                    
                                    
                                       (
                                       
                                          
                                             Q
                                             
                                                i
                                                j
                                             
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        For experiments and analysis in the paper, we use both the stationary kernel function (7) and the non-stationary kernel function (13). In this paper, only isotropic covariances are used. The introduction of spatially varying kernels raises an important problem of estimating the lengthscale of a data point. Lang et al. [24] have extended well establish Gaussian process regression technique for terrain modeling, which utilizes non-stationary covariance functions to locally adapt the structure of the range data. Plagemann et al. [21] have used isotropic covariance functions which vary only in lengthscale for surface reconstruction. The parameter of lengthscale is estimated from range data by computing the gradient elevation from local neighborhood around the covariance function. The range data acquired from the Laser range scanner have some specific characteristic such as if the distance from the range sensor increases, the data density non-uniformly decreases, and obtain more sparsely terrain information. Accordingly, the lengthscale increases, providing more support and smoother reconstruction. Therefore, for a given non-uniform distribution of range data, the variable lengthscales are computed according to a piece-wise linear function of the distance of the range data point from the range sensor. The variable lengthscales are defined as

                           
                              
                                 
                                    σ
                                    
                                       (
                                       
                                          x
                                          i
                                       
                                       )
                                    
                                    =
                                    m
                                    i
                                    n
                                    
                                       (
                                       
                                          γ
                                          ∥
                                       
                                       
                                          r
                                          
                                             d
                                             i
                                          
                                       
                                       
                                          
                                             ∥
                                          
                                          2
                                       
                                       ,
                                       
                                          σ
                                          
                                             t
                                             h
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        where (x
                        
                           i
                        ) is the ray connecting the range sensor and 3D data point x
                        
                           i
                        , γ is scaling factor and σth
                         is a threshold lengthscale, i.e., a fixed maximum lengthscale [21,24]. The variable lengthscale function is used to determine the covariance of each data point added to the kernel function. In order to solve the optimization problem, we use a functional gradient descent method that relies on sub-gradients to deal non-differentiable problems, i.e., a kernel-based sub-gradient method, partly inspired by the fact that there have been fast and efficient algorithms developed for its computation.

The sub-gradient method iteratively computes a gradient like vector that is defined using a tangent to the lower bound at a specific point of non-differentiable convex function. There is a continuum of sub-gradients at each point of the non-differentiability, but has a unique sub-gradient which is the gradient at differentiable points. A detailed explanation of the subgradient descent method can be found in [30]. Zinkevich [31] has developed the online gradient descent method with the regret bounds for the sub-gradient methods. In order to learn the function through functional sub-gradient descent method, the function updates with a negative step of the sub-gradient by a learning rate η:

                           
                              (14)
                              
                                 
                                    
                                       f
                                       
                                          t
                                          +
                                          1
                                       
                                    
                                    ←
                                    
                                       f
                                       t
                                    
                                    −
                                    
                                       η
                                       t
                                    
                                    
                                       
                                          ∂
                                          L
                                          
                                             (
                                             f
                                             ,
                                             
                                                x
                                                t
                                             
                                             ,
                                             
                                                y
                                                t
                                             
                                             )
                                          
                                       
                                       
                                          ∂
                                          f
                                       
                                    
                                 
                              
                           
                        Since function (f) is a hypothesis in reproducing kernel Hilbert space (RKHS), from Eq. (4)
                        
                           
                              (15)
                              
                                 
                                    
                                       
                                          ∂
                                          L
                                          
                                             (
                                             
                                                x
                                                t
                                             
                                             ,
                                             
                                                y
                                                t
                                             
                                             ,
                                             f
                                             
                                                (
                                                
                                                   x
                                                   t
                                                
                                                )
                                             
                                             )
                                          
                                       
                                       
                                          ∂
                                          f
                                       
                                    
                                    =
                                    
                                       r
                                       ′
                                    
                                    
                                       (
                                       
                                          x
                                          t
                                       
                                       ,
                                       
                                          y
                                          t
                                       
                                       ,
                                       f
                                       
                                          (
                                          
                                             x
                                             t
                                          
                                          )
                                       
                                       )
                                    
                                    k
                                    
                                       (
                                       
                                          x
                                          t
                                       
                                       ,
                                       .
                                       )
                                    
                                    +
                                    λ
                                    f
                                 
                              
                           
                         
                        Eq. (14) reduces to

                           
                              (16)
                              
                                 
                                    
                                       f
                                       
                                          t
                                          +
                                          1
                                       
                                    
                                    ←
                                    
                                       (
                                       1
                                       −
                                       
                                          η
                                          t
                                       
                                       λ
                                       )
                                    
                                    
                                       f
                                       t
                                    
                                    −
                                    
                                       η
                                       t
                                    
                                    
                                       r
                                       ′
                                    
                                    
                                       (
                                       
                                          x
                                          t
                                       
                                       ,
                                       
                                          y
                                          t
                                       
                                       ,
                                       f
                                       
                                          (
                                          
                                             x
                                             t
                                          
                                          )
                                       
                                       )
                                    
                                    k
                                    
                                       (
                                       
                                          x
                                          t
                                       
                                       ,
                                       .
                                       )
                                    
                                 
                              
                           
                        The kernel expansion of f (Eq. 6) to derive an efficient stochastic update, following the example of [28] with zero initial hypothesis being 
                           
                              
                                 f
                                 1
                              
                              =
                              0
                           
                        . In this stochastic method, basis functions are added iteratively and weight of previously updated basis functions are decayed at the same time. The number and position of the basis function is not similar to the labeled data points, and the final number of basis functions may be fewer or greater than the sample size. Thus, at a particular time, a new basis function may be added to location x
                        
                           t
                         with coefficient α given by

                           
                              (17)
                              
                                 
                                    
                                       α
                                       i
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   −
                                                   
                                                      η
                                                      t
                                                   
                                                   
                                                      r
                                                      ′
                                                   
                                                   
                                                      (
                                                      
                                                         x
                                                         t
                                                      
                                                      ,
                                                      
                                                         y
                                                         t
                                                      
                                                      ,
                                                      f
                                                      
                                                         (
                                                         
                                                            x
                                                            t
                                                         
                                                         )
                                                      
                                                      )
                                                   
                                                   ,
                                                
                                             
                                             
                                                
                                                   if
                                                   
                                                   
                                                   i
                                                   =
                                                   t
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      (
                                                      1
                                                      −
                                                      
                                                         η
                                                         t
                                                      
                                                      λ
                                                      )
                                                   
                                                   
                                                      α
                                                      i
                                                   
                                                   ,
                                                
                                             
                                             
                                                
                                                   if
                                                   
                                                   1
                                                   <
                                                   i
                                                   <
                                                   t
                                                   −
                                                   1
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        The above method performs iteratively until 
                           
                              
                                 (
                                 
                                    t
                                    <
                                    T
                                    ∥
                                 
                                 
                                    α
                                    
                                       t
                                       −
                                       k
                                    
                                 
                                 :
                                 
                                    α
                                    t
                                 
                                 <
                                 ϵ
                                 )
                              
                              ,
                           
                         where T and ϵ are the max iteration and threshold criterion for stopping. In summary, we have used a functional sub-gradient descent method that depends on subgradients to solve non-differentiable problems.

@&#EXPERIMENTAL RESULTS@&#

The proposed surface estimation approach has been implemented on the range data obtained from LRS (shown in Fig. 1). In order to acquire the range data, the angular rotation command is sent to stepper motor from a personal computer via ZigBee. The stepper motor moves the camera-Laser setup in the micro-stepping rotation (i.e., angular resolution 
                        
                           0
                           .
                           
                              1125
                              ∘
                           
                        
                     ) using a micro stepper driver (A4988). Due to angular rotation, we obtain very dense range data within a few meters from the range scanner, but it quickly decays to a sparse, uneven distribution. The acquired range data is extremely rugged and composed of irregular piles of the rubble. Therefore, we set the camera such that it sees the terrain up to 2–2.5 meters, so that we could obtain the good quality of the range data. The sampled points lying on the exterior and the interior are generated as 
                        
                           
                              p
                              +
                           
                           =
                           
                              (
                              1
                              +
                              δ
                              )
                           
                           p
                           +
                           δ
                           C
                           ,
                        
                     
                     
                        
                           
                              p
                              ×
                           
                           =
                           
                              (
                              1
                              −
                              δ
                              )
                           
                           p
                           −
                           δ
                           C
                           ,
                        
                      where p and C are the range data and the range sensor location respectively. In this way, we have generated the exterior (positive samples) and interior (negative samples) of range data, i.e., labeled data points with associated labels. The value of λ is set to 
                        
                           1
                           
                              100
                              N
                           
                        
                      and learning rate ηt
                      to 
                        
                           
                              1
                              
                                 2
                                 
                                    t
                                 
                              
                           
                           
                              η
                              0
                           
                           ,
                        
                      where N is the size of the data-set and η
                     0 is a constant value. A line search is performed on the ray γrdi
                     (x
                     
                        i
                     , C) that connects the sensor to 3D points, where x
                     
                        i
                      denotes the data points, C is the sensor location and γ is a constant scaling factor. The computation of sub-gradient method requires to minimize Eq.(4), which finds the most violated point among the continuum of 3D points lying along the ray for each data sample. The experiments described in the paper have been conducted on a 3.4 GHz, core i-7, 8GB RAM, 64 bit computer using a preliminary Matlab-14a implementation. In the first experiment, we have generated a highly unstructured terrain in the robotics lab as shown in Fig. 4
                     (a). Fig. 4(b) shows the distribution of point cloud data which is obtained from LRS. Fig. 4(c) shows the exterior, interior, range data and estimated surface of the terrain. Fig. 4(d) shows the estimated surface without using ray information and Fig. 4(e) shows the improved result of the estimated surface by incorporating the ray-based constraints. The surface reconstruction is achieved from interpolated data which is obtained from the minimized objective function. In the paper, the estimated surface from 3D point cloud have been generated using irregular triangulated meshes (ITM’s), instead of the grid based method because the triangulated surface produces the uneven characteristic of the terrain at every location of acquired range data, thus making it more efficient to generate the sudden elevation changes of the terrain. However, the computation complexity of the ITM’s depends upon the data density. For an example, in the boulder’s sandy terrain as shown in fig. 4, the range data set with over 0.5 million sampled points is iteratively processed to generate the accurate surface in a few minutes. On the other hand, the grid based methods represent the terrain as a regularly spaced grid structure. The main disadvantages of grid based methods are the lack of a statistically direct way of handling elevation uncertainty and the inability to accurately handle spatial correlation. Therefore, in the field of robotics, irregular triangulated meshes (ITM’s) are more useful for 3D surface/object modeling. The sub-gradient algorithm is terminated when the risk functional value is less than a threshold value. Fig. 4 shows that the proposed method is able to estimate the separating hyper-plane using above presented max-margin formulation and kernel based sub-gradient optimization. Since the density of range data decays rapidly away from the range sensor (see Fig. 4(b)). In the experiments, the unstructured surface is poorly estimated in the case of without using ray information (see Fig. 4(d)). Therefore, from Fig. 4(d) and 4(e), we observe that the inclusion of visibility information generates more accurate surface. In order to show the contribution of ray based information, the mean squared error is evaluated by comparing the predicted surface elevation relative to a set of test data points. The mean squared error (MSE) is calculated as:

                        
                           (18)
                           
                              
                                 M
                                 S
                                 E
                                 
                                    (
                                    
                                       χ
                                       t
                                    
                                    )
                                 
                                 =
                                 
                                    1
                                    n
                                 
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    n
                                 
                                 
                                    (
                                    f
                                    
                                       (
                                       
                                          x
                                          i
                                       
                                       )
                                    
                                    −
                                    
                                       z
                                       i
                                    
                                    )
                                 
                              
                           
                        
                     where set of test data 
                        
                           
                              χ
                              t
                           
                           =
                           
                              
                                 {
                                 
                                    x
                                    i
                                 
                                 }
                              
                              
                                 i
                                 =
                                 1
                              
                              n
                           
                        
                      with known elevation zi
                     .

The comparison of mean square error on range data of the boulder-sandy terrain after convergence of the algorithm with increasing sample sizes using with and without ray based information is shown in Fig. 5
                     (a) which clearly demonstrates the benefit of the ray constraints. The MSE of estimated surface using ray constraints sharply decreases with respect to the increasing sample size in comparison to without using ray constraints. If we use sufficiently large amount of sample data, the error margin between the two methods (with and without using ray constraints) is very small because the Laser range sensor gives a good quality range data of the terrain. If we estimate the surface from noisy 3D data, the potential gain of the visibility information will be more effective. Therefore, the proposed approach exploits the ray-information on Laser scanning to improve the surface estimate even in the sparser regions. Also, ray-based constraints are used to get rid of the spurious bumps produced by unwanted disturbance (erroneous behavior) during scanning.

The MSE convergence of different methods for boulder-sandy data at distinct sample size using visibility constraint has been shown in Fig. 5(b). In the figure, the green plot demonstrates the performance of surface estimation method using stationary Wu kernel function [26]. In this method, the fixed lengthscales (σ) of kernel function have been used which affects the smoothness of the resulting objective function. Therefore, this method produces a small but significant amount of error in the reconstructed surface. The red plot shows the performance of the surface generated using non-stationary Gaussian kernel [24,32]. This method utilizes Gaussian processes with non-stationary covariance functions to locally adapt the surface geometry of the terrain data. The MSE of non-stationary Gaussian process is reduced by approximately 28% from the stationary kernel based method, if 0.56 million sample data is used as a labeled data set. The pink plot shows the performance of the Hadsell method [27]. Hadsell et al. have computed variable lengthscales (σ) according to a piecewise constant of non-stationary kernel function to generate the surface model. The margin of error between Hadsell method and proposed method for a large data-set is very small but the time complexity of Hadsell method is very large as compared to proposed method, i.e., proposed method generates the surface more than 10 times faster than Hadsell method at a specific sampled size. The green plot shows the performance of the proposed method at different sample sizes. Compared to the other existing methods from the literature, prediction error (MSE) of the proposed method is less than other existing methods at each used sampled points, like MSE is 2.4 mm at 0.56 million sampled data. Therefore, the proposed method generates accurate surface of the rough terrain.

Many surface estimation experiments have been performed by generating different kinds of the terrain. Fig. 6
                     (a) show the more rugged sandy terrain and its estimated surface model is shown in Fig 6(d). Fig 6(b--c) shows the different types of blocks placed in sandy terrain and its estimated surface model is shown in Fig 6(e--f). Similarly, we place the plywood board which consists of 15 wooden slabs placed at 5 cm from the first visible position in the terrain as shown in Fig. 6(d). We perform this experiment to examine the robustness of the proposed method, i.e., proper estimation of the surface. Fig 6(g) shows the accurate reconstruction of the surface model. Thus, the proposed approach is applicable to the real world problem for accurate surface reconstruction and object modeling from a large data set.

@&#CONCLUSIONS@&#

In this paper, we have presented a new formulation based on a max-margin framework and then described a minimization of an objective function using a non-stationary kernel-based sub-gradient method. Additionally, the use of ray-based information improves the surface fitting. Experimental results validate the proposed method for generating accurate surface maps and show improved results upon inclusion of the ray-based constraints. Compared to other existing techniques from the literature, the proposed method has given the least mean square error of generated surface, which clearly validates the effectiveness of the proposed approach. The proposed method can allow range data to be added online and performs as a real-time algorithm. In the future, we wish to expand the proposed surface estimation method to include extensive range data input over multiple time-steps for online path planning applications in mobile robot navigation. We further intend to develop a SLAM technique where the trajectory of the mobile robot will be unknown, and the surface model will have to be updated sequentially.

@&#REFERENCES@&#

